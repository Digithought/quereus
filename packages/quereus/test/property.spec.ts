import { expect } from 'chai';
import * as fc from 'fast-check';
import { Database } from '../src/core/database.js'; // Adjust path as needed
import { compareSqlValues } from '../src/util/comparison.js'; // Import compare helper
import { safeJsonStringify } from '../src/util/serialization.js';
import type { SqlParameters, SqlValue } from '../src/common/types.js'; // Import SqlParameters

describe('Property-Based Tests', () => {
	let db: Database;

	beforeEach(() => {
		db = new Database();
		// Ensure collations are registered (already done in Database constructor)
	});

	afterEach(async () => {
		await db.close();
	});

	// --- 1. Collation Comparator ---
	describe('Collation Comparator', () => {
		const collationsToTest = ['BINARY', 'NOCASE', 'RTRIM'];

		for (const collationName of collationsToTest) {
			it(`should sort consistently with compare function for ${collationName} collation`, async () => {
				await db.exec(`CREATE TABLE coll_t (id INTEGER PRIMARY KEY, txt TEXT COLLATE ${collationName}) USING memory`);

				await fc.assert(fc.asyncProperty(fc.array(fc.string(), { minLength: 1, maxLength: 20 }), async (strings) => {
					// Use a Map to handle potential duplicate strings generated by fast-check, preserving insertion order for comparison
					const uniqueStringsMap = new Map<string, boolean>();
					strings.forEach(s => uniqueStringsMap.set(s, true));
					const uniqueStrings = Array.from(uniqueStringsMap.keys());

					// Reset table for each property run
					await db.exec('DELETE FROM coll_t');
					const stmt = db.prepare('INSERT INTO coll_t (txt) VALUES (?)');
					try {
						for (const str of uniqueStrings) {
							await stmt.run([str]);
						}
					} finally {
						await stmt.finalize();
					}

					// Get sorted results from the database
					const dbSorted: Record<string, any>[] = [];
					for await (const row of db.eval(`SELECT txt FROM coll_t ORDER BY txt`)) {
						dbSorted.push(row);
					}
					const dbSortedStrings = dbSorted.map((row: Record<string, any>) => row.txt as string);

					// Sort the original unique strings using the JavaScript compare function
					const jsSortedStrings = [...uniqueStrings].sort((a, b) => compareSqlValues(a, b, collationName));

					// Compare the two sorted lists
					expect(dbSortedStrings).to.deep.equal(jsSortedStrings, `Mismatch for collation ${collationName} with input: ${safeJsonStringify(uniqueStrings)}`);
				}), { numRuns: 50 }); // Keep numRuns reasonable for CI
			});
		}
	});

	// --- 2. Numeric Affinity ---
	describe('Numeric Affinity', () => {
		// Define an arbitrary that generates values representable as NULL, INTEGER, REAL, or TEXT that might look numeric
		const sqlValueArbitrary = fc.oneof(
			fc.constant(null),
			fc.integer(),
			fc.float({ noNaN: true }), // Exclude NaN as it complicates SQL comparisons
			fc.boolean(),
			fc.string(), // Includes numeric-looking strings
			fc.bigInt()
			// fc.uint8Array() // Skip BLOBs for numeric affinity tests
		);

		it('should compare values according to numeric affinity', async () => {
			await db.exec('CREATE TABLE num_t (id INTEGER PRIMARY KEY, v ANY) USING memory'); // Use ANY type

			await fc.assert(fc.asyncProperty(sqlValueArbitrary, sqlValueArbitrary, async (valA, valB) => {
				// Use compareSqlValues as the JS source of truth for how values *should* compare
				const expectedComparison = compareSqlValues(valA, valB, 'BINARY'); // Use BINARY as base for comparison logic

				// Query the database to see how it compares the values
				let dbComparison: number;
				try {
					// Check A = B using eval and taking the first row
					let eqResult: Record<string, any> | undefined;
					for await (const row of db.eval('SELECT ? = ? as result', [valA, valB])) { // Cast
						eqResult = row;
						break; // Only need the first (and only) row
					}
					if (eqResult?.result) {
						dbComparison = 0;
					} else {
						// Check A < B using eval and taking the first row
						let ltResult: Record<string, any> | undefined;
						for await (const row of db.eval('SELECT ? < ? as result', [valA, valB])) { // Cast
							ltResult = row;
							break; // Only need the first row
						}
						dbComparison = ltResult?.result ? -1 : 1;
					}
				} catch (e: any) {
					// If the comparison itself throws an error in SQL, fail the property test
					fc.pre(false); // Discard this run if SQL comparison fails
					throw new Error(`SQL comparison failed for (${valA}, ${valB}): ${e.message}`);
				}

				expect(dbComparison).to.equal(expectedComparison,
					`Mismatch for compare(${safeJsonStringify(valA)}, ${safeJsonStringify(valB)}). JS=${expectedComparison}, DB=${dbComparison}`
				);
			}), { numRuns: 200 }); // Increase runs for more diverse value pairs
		});

		// TODO: Add tests for aggregation functions with mixed types (e.g., SUM('1', 2))
	});

	// --- 3. JSON Roundtrip ---
	describe('JSON Roundtrip', () => {
		const jsonValueArbitrary = fc.jsonValue();

		it('should preserve JSON values through json() and json_extract()', async () => {
			await fc.assert(fc.asyncProperty(jsonValueArbitrary, async (originalValue) => {
				let retrievedValueParsed: any;
				try {
					let resultRow: Record<string, any> | undefined;
					for await (const row of db.eval("SELECT json_extract(json_quote(?), '$') as result", [originalValue as SqlValue])) {
						resultRow = row;
						break; // We only expect one row from this SELECT
					}

					if (resultRow) {
						retrievedValueParsed = resultRow.result;
					} else {
						// This case should ideally not be hit if originalValue is valid for json_quote
						// and json_extract can process it. If it is, it might indicate an issue
						// with how null/empty results are handled by db.eval or the underlying functions.
						// For certain inputs like trying to json_quote a function or symbol (which fc.jsonValue should not produce),
						// an error might occur during SQL execution, caught by the outer catch block.
						// If the query legitimately returns no rows (e.g. SELECT FROM empty_table), this branch would be hit.
						// But SELECT json_extract(...) should always return one row.
						throw new Error('json_extract query returned no result row unexpectedly.');
					}
				} catch (e: any) {
					fc.pre(false); // Discard this run if SQL execution fails
					throw new Error(`JSON roundtrip query failed for value ${safeJsonStringify(originalValue)}: ${e.message}`);
				}
				expect(retrievedValueParsed).to.deep.equal(originalValue,
					`JSON roundtrip mismatch.\nOriginal: ${safeJsonStringify(originalValue)}\nRetrieved: ${safeJsonStringify(retrievedValueParsed)}`
				);
			}), { numRuns: 200 });
		});
	});

});
