import { expect } from 'chai';
import * as fc from 'fast-check';
import { Database } from '../src/core/database.js'; // Adjust path as needed
import { compareSqlValues } from '../src/util/comparison.js'; // Import compare helper
import { safeJsonStringify } from '../src/util/serialization.js';
import type { SqlValue } from '../src/common/types.js'; // Import SqlParameters

describe('Property-Based Tests', () => {
	let db: Database;

	beforeEach(() => {
		db = new Database();
		// Ensure collations are registered (already done in Database constructor)
	});

	afterEach(async () => {
		await db.close();
	});

	/**
	 * Deep equality comparison that treats -0 and +0 as equal,
	 * since JSON cannot preserve the distinction between them.
	 */
	function deepEqualIgnoringZeroSign(actual: any, expected: any): boolean {
		if (actual === expected) return true;

		// Handle the -0 vs +0 case
		if (typeof actual === 'number' && typeof expected === 'number' &&
			actual === 0 && expected === 0) {
			return true; // Treat -0 and +0 as equal
		}

		// Handle arrays
		if (Array.isArray(actual) && Array.isArray(expected)) {
			if (actual.length !== expected.length) return false;
			for (let i = 0; i < actual.length; i++) {
				if (!deepEqualIgnoringZeroSign(actual[i], expected[i])) return false;
			}
			return true;
		}

		// Handle objects
		if (actual !== null && expected !== null &&
			typeof actual === 'object' && typeof expected === 'object') {
			const actualKeys = Object.keys(actual);
			const expectedKeys = Object.keys(expected);
			if (actualKeys.length !== expectedKeys.length) return false;

			for (const key of actualKeys) {
				if (!expectedKeys.includes(key)) return false;
				if (!deepEqualIgnoringZeroSign(actual[key], expected[key])) return false;
			}
			return true;
		}

		return false;
	}

	// --- 1. Collation Comparator ---
	describe('Collation Comparator', () => {
		const collationsToTest = ['BINARY', 'NOCASE', 'RTRIM'];

		for (const collationName of collationsToTest) {
			it(`should sort consistently with compare function for ${collationName} collation`, async () => {
				await db.exec(`CREATE TABLE coll_t (id INTEGER PRIMARY KEY, txt TEXT COLLATE ${collationName}) USING memory`);

				await fc.assert(fc.asyncProperty(fc.array(fc.string(), { minLength: 1, maxLength: 20 }), async (strings) => {
					// Use a Map to handle potential duplicate strings generated by fast-check, preserving insertion order for comparison
					const uniqueStringsMap = new Map<string, boolean>();
					strings.forEach(s => uniqueStringsMap.set(s, true));
					const uniqueStrings = Array.from(uniqueStringsMap.keys());

					// Reset table for each property run
					await db.exec('DELETE FROM coll_t');
					const stmt = db.prepare('INSERT INTO coll_t (id, txt) VALUES (?, ?)');
					try {
						for (let i = 0; i < uniqueStrings.length; i++) {
							await stmt.run([i + 1, uniqueStrings[i]]);
						}
					} finally {
						await stmt.finalize();
					}

					// Get sorted results from the database
					const dbSorted: Record<string, any>[] = [];
					for await (const row of db.eval(`SELECT txt FROM coll_t ORDER BY txt`)) {
						dbSorted.push(row);
					}
					const dbSortedStrings = dbSorted.map((row: Record<string, any>) => row.txt as string);

					// Sort the original unique strings using the JavaScript compare function
					const jsSortedStrings = [...uniqueStrings].sort((a, b) => compareSqlValues(a, b, collationName));

					// Compare the two sorted lists
					expect(dbSortedStrings).to.deep.equal(jsSortedStrings, `Mismatch for collation ${collationName} with input: ${safeJsonStringify(uniqueStrings)}`);
				}), { numRuns: 50 }); // Keep numRuns reasonable for CI
			});
		}
	});

		// --- 2. Numeric Affinity ---
	describe('Numeric Affinity', () => {
		// Define an arbitrary that generates values representable as NULL, INTEGER, REAL, or TEXT that might look numeric
		const sqlValueArbitrary = fc.oneof(
			fc.constant(null),
			fc.integer(),
			fc.float({ noNaN: true }), // Exclude NaN as it complicates SQL comparisons
			fc.boolean(),
			fc.string(), // Includes numeric-looking strings
			fc.bigInt()
			// fc.uint8Array() // Skip BLOBs for numeric affinity tests
		);

		it('should compare values according to numeric affinity', async () => {
			await db.exec('CREATE TABLE num_t (id INTEGER PRIMARY KEY, v ANY) USING memory'); // Use ANY type (has NUMERIC affinity)

			await fc.assert(fc.asyncProperty(sqlValueArbitrary, sqlValueArbitrary, async (valA, valB) => {
				// Insert values and let SQL apply type affinity conversion
				await db.exec('DELETE FROM num_t');
				const stmt = db.prepare('INSERT INTO num_t (id, v) VALUES (?, ?)');
				try {
					await stmt.run([1, valA]);
					await stmt.run([2, valB]);
				} finally {
					await stmt.finalize();
				}

				// Retrieve the actual values after type affinity conversion
				const actualValues: SqlValue[] = [];
				for await (const row of db.eval('SELECT v FROM num_t ORDER BY id')) {
					actualValues.push(row.v);
				}
				const [actualA, actualB] = actualValues;

				// Now compare using the converted values (what SQL actually stored)
				const expectedComparison = compareSqlValues(actualA, actualB, 'BINARY');

				// Test ordering behavior using ORDER BY
				const orderedValues: SqlValue[] = [];
				for await (const row of db.eval('SELECT v FROM num_t ORDER BY v')) {
					orderedValues.push(row.v);
				}

				// Check if the ordering matches our expectation based on converted values
				if (expectedComparison < 0) {
					expect(orderedValues).to.deep.equal([actualA, actualB],
						`ORDER BY should place ${safeJsonStringify(actualA)} before ${safeJsonStringify(actualB)}`);
				} else if (expectedComparison > 0) {
					expect(orderedValues).to.deep.equal([actualB, actualA],
						`ORDER BY should place ${safeJsonStringify(actualB)} before ${safeJsonStringify(actualA)}`);
				} else {
					// Equal values - order doesn't matter, but both should be present
					expect(orderedValues).to.have.lengthOf(2);
					expect(orderedValues).to.include(actualA);
					expect(orderedValues).to.include(actualB);
				}

				// For non-NULL values, also test SQL boolean comparisons
				if (actualA !== null && actualB !== null) {
					let dbComparison: number;
					try {
						// Check A = B using eval and taking the first row
						let eqResult: Record<string, any> | undefined;
						for await (const row of db.eval('SELECT ? = ? as result', [actualA, actualB])) {
							eqResult = row;
							break; // Only need the first (and only) row
						}
						if (eqResult?.result) {
							dbComparison = 0;
						} else {
							// Check A < B using eval and taking the first row
							let ltResult: Record<string, any> | undefined;
							for await (const row of db.eval('SELECT ? < ? as result', [actualA, actualB])) {
								ltResult = row;
								break; // Only need the first row
							}
							dbComparison = ltResult?.result ? -1 : 1;
						}
					} catch (e: any) {
						// If the comparison itself throws an error in SQL, fail the property test
						fc.pre(false); // Discard this run if SQL comparison fails
						throw new Error(`SQL comparison failed for (${actualA}, ${actualB}): ${e.message}`);
					}

					expect(dbComparison).to.equal(expectedComparison,
						`Mismatch for compare(${safeJsonStringify(actualA)}, ${safeJsonStringify(actualB)}). JS=${expectedComparison}, DB=${dbComparison}`
					);
				}
			}), { numRuns: 200 }); // Increase runs for more diverse value pairs
		});
	});

	// --- 3. JSON Roundtrip ---
	describe('JSON Roundtrip', () => {
		const jsonValueArbitrary = fc.jsonValue();

		it('should preserve JSON values through json() and json_extract()', async () => {
			await fc.assert(fc.asyncProperty(jsonValueArbitrary, async (originalValue) => {
				let retrievedValueParsed: any;
				try {
					let resultRow: Record<string, any> | undefined;
					for await (const row of db.eval("SELECT json_extract(json_quote(?), '$') as result", [originalValue as SqlValue])) {
						resultRow = row;
						break; // We only expect one row from this SELECT
					}

					if (resultRow) {
						retrievedValueParsed = resultRow.result;
					} else {
						// This case should ideally not be hit if originalValue is valid for json_quote
						// and json_extract can process it. If it is, it might indicate an issue
						// with how null/empty results are handled by db.eval or the underlying functions.
						// For certain inputs like trying to json_quote a function or symbol (which fc.jsonValue should not produce),
						// an error might occur during SQL execution, caught by the outer catch block.
						// If the query legitimately returns no rows (e.g. SELECT FROM empty_table), this branch would be hit.
						// But SELECT json_extract(...) should always return one row.
						throw new Error('json_extract query returned no result row unexpectedly.');
					}
				} catch (e: any) {
					fc.pre(false); // Discard this run if SQL execution fails
					throw new Error(`JSON roundtrip query failed for value ${safeJsonStringify(originalValue)}: ${e.message}`);
				}

				// Handle the different ways json_extract returns values based on SQLite compatibility:
				// - Objects/arrays: returned as JSON strings
				// - Booleans: converted to integers (1/0)
				// - Numbers/strings/null: returned as-is

				if (typeof retrievedValueParsed === 'string' && (typeof originalValue === 'object' && originalValue !== null)) {
					// Objects and arrays are returned as JSON strings - parse them for comparison
					try {
						const parsedRetrieved = JSON.parse(retrievedValueParsed);
						const isEqual = deepEqualIgnoringZeroSign(parsedRetrieved, originalValue);
						void expect(isEqual,
							`JSON roundtrip mismatch after parsing string result.\nOriginal: ${safeJsonStringify(originalValue)}\nRetrieved (raw): ${safeJsonStringify(retrievedValueParsed)}\nRetrieved (parsed): ${safeJsonStringify(parsedRetrieved)}`
						).to.be.true;
					} catch (parseError) {
						throw new Error(`JSON roundtrip failed - could not parse retrieved string.\nOriginal: ${safeJsonStringify(originalValue)}\nRetrieved: ${safeJsonStringify(retrievedValueParsed)}\nParse error: ${parseError instanceof Error ? parseError.message : String(parseError)}`);
					}
				} else if (typeof originalValue === 'boolean' && typeof retrievedValueParsed === 'number') {
					// Booleans are converted to integers by json_extract (SQLite compatibility)
					const expectedInteger = originalValue ? 1 : 0;
					void expect(retrievedValueParsed).to.equal(expectedInteger,
						`JSON boolean roundtrip mismatch.\nOriginal boolean: ${originalValue}\nExpected integer: ${expectedInteger}\nRetrieved: ${retrievedValueParsed}`
					);
				} else {
					// For other scalars (numbers, strings, null), use zero-sign-aware comparison
					const isEqual = deepEqualIgnoringZeroSign(retrievedValueParsed, originalValue);
					void expect(isEqual,
						`JSON roundtrip mismatch.\nOriginal: ${safeJsonStringify(originalValue)} (type: ${typeof originalValue})\nRetrieved: ${safeJsonStringify(retrievedValueParsed)} (type: ${typeof retrievedValueParsed})`
					).to.be.true;
				}
			}), { numRuns: 200 });
		});
	});

	// --- 4. Mixed Type Arithmetic Edge Cases ---
	describe('Mixed Type Arithmetic Edge Cases', () => {
		const complexValueArbitrary = fc.oneof(
			fc.constant(null),
			fc.integer({ min: -1000, max: 1000 }),
			fc.float({ min: -1000, max: 1000, noNaN: true }),
			fc.boolean(),
			fc.oneof(
				fc.string({ minLength: 0, maxLength: 5 }),
				fc.integer().map(n => n.toString()),
				fc.float().map(n => n.toString()),
				fc.constant(''),
				fc.constant('0'),
				fc.constant('1'),
				fc.constant('true'),
				fc.constant('false')
			)
		);

		it('should handle mixed type arithmetic consistently across contexts', async () => {
			await db.exec('CREATE TABLE mixed_test (id INTEGER PRIMARY KEY, a ANY, b ANY) USING memory');

			await fc.assert(fc.asyncProperty(complexValueArbitrary, complexValueArbitrary, async (valA, valB) => {
				// Clear table and insert test values
				await db.exec('DELETE FROM mixed_test');
				const stmt = db.prepare('INSERT INTO mixed_test (id, a, b) VALUES (?, ?, ?)');
				try {
					await stmt.run([1, valA, valB]);
				} finally {
					await stmt.finalize();
				}

				// Test arithmetic in different contexts - they should all produce the same result or all fail
				let selectResult: any = undefined;
				let selectFailed = false;
				let whereResult: any = undefined;
				let whereFailed = false;

				// Test in SELECT
				try {
					for await (const row of db.eval('SELECT (a + b) as result FROM mixed_test')) {
						selectResult = row.result;
						break;
					}
				} catch {
					selectFailed = true;
				}

				// Test in WHERE (using a comparison to ensure arithmetic works)
				try {
					for await (const row of db.eval('SELECT (a + b) as result FROM mixed_test WHERE (a + b) = (a + b)')) {
						whereResult = row.result;
						break;
					}
				} catch {
					whereFailed = true;
				}

				// Both should succeed or both should fail
				expect(selectFailed).to.equal(whereFailed,
					`Arithmetic behavior inconsistent between SELECT and WHERE for (${safeJsonStringify(valA)}, ${safeJsonStringify(valB)})`);

				// If both succeeded, results should match
				// Note: if selectResult is null, whereResult might be undefined (no rows returned)
				// This is expected behavior when the result is null
				if (!selectFailed && !whereFailed) {
					if (selectResult === null) {
						// If SELECT returns null, WHERE with self-comparison should return no rows (undefined)
						// This is actually correct behavior - NULL != NULL in SQL
						void expect(whereResult).to.be.undefined;
					} else {
						// For non-null results, they should match exactly
						expect(selectResult).to.equal(whereResult,
							`Arithmetic results differ between SELECT and WHERE for (${safeJsonStringify(valA)}, ${safeJsonStringify(valB)})`);
					}
				}
			}), { numRuns: 100 });
		});
	});

});
