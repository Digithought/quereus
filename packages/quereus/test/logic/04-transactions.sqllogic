-- transactions.sqllogic - Testing BEGIN, COMMIT, ROLLBACK, SAVEPOINT, and implicit transactions

-- ===================================
-- Implicit Transaction Tests
-- ===================================
-- When not in an explicit transaction (autocommit mode), each statement
-- or batch of statements is automatically wrapped in an implicit transaction

CREATE TABLE implicit_tx (id INTEGER PRIMARY KEY, val TEXT);

-- Single statement should auto-commit
INSERT INTO implicit_tx VALUES (1, 'auto-committed');
SELECT val FROM implicit_tx WHERE id = 1;
→ [{ "val": "auto-committed" }]

-- Multiple statements in one exec should be atomic (all or nothing)
INSERT INTO implicit_tx VALUES (2, 'batch-a');
INSERT INTO implicit_tx VALUES (3, 'batch-b');
INSERT INTO implicit_tx VALUES (4, 'batch-c');
SELECT count(*) as cnt FROM implicit_tx;
→ [{ "cnt": 4 }]

-- Error in batch should rollback entire batch
-- This should fail on duplicate key and rollback both inserts
INSERT INTO implicit_tx VALUES (10, 'new1');
INSERT INTO implicit_tx VALUES (1, 'duplicate');
INSERT INTO implicit_tx VALUES (11, 'new2');
-- error: UNIQUE constraint failed

-- Verify the failed batch was rolled back (row 10 should not exist)
SELECT count(*) as cnt FROM implicit_tx WHERE id = 10;
→ [{ "cnt": 0 }]
SELECT count(*) as cnt FROM implicit_tx WHERE id = 11;
→ [{ "cnt": 0 }]

-- Original data should be intact
SELECT count(*) as cnt FROM implicit_tx;
→ [{ "cnt": 4 }]

DROP TABLE implicit_tx;

-- ===================================
-- Explicit Transaction Tests
-- ===================================

CREATE TABLE tx_t (id INTEGER PRIMARY KEY, val TEXT);
INSERT INTO tx_t VALUES (1, 'initial');

-- Basic COMMIT
BEGIN TRANSACTION;
INSERT INTO tx_t VALUES (2, 'tx1');
SELECT val FROM tx_t WHERE id = 2;
→ [{ "val": "tx1" }]
COMMIT;
SELECT val FROM tx_t WHERE id = 2;
→ [{ "val": "tx1" }]

-- Basic ROLLBACK
BEGIN TRANSACTION;
UPDATE tx_t SET val = 'tx2_update' WHERE id = 1;
INSERT INTO tx_t VALUES (3, 'tx2');
SELECT val FROM tx_t WHERE id = 1;
→ [{ "val": "tx2_update" }]
SELECT val FROM tx_t WHERE id = 3;
→ [{ "val": "tx2" }]
ROLLBACK;
SELECT val FROM tx_t WHERE id = 1;
→ [{ "val": "initial" }]
SELECT count(*) FROM tx_t WHERE id = 3;
→ [{ "count(*)": 0 }]

-- SAVEPOINT and RELEASE
BEGIN TRANSACTION;
INSERT INTO tx_t VALUES (4, 'before_sp1');
SAVEPOINT sp1;
INSERT INTO tx_t VALUES (5, 'after_sp1');
SELECT val FROM tx_t WHERE id = 5;
→ [{ "val": "after_sp1" }]
RELEASE SAVEPOINT sp1;
-- sp1 is now merged into the main transaction
COMMIT;
SELECT val FROM tx_t WHERE id = 4;
→ [{ "val": "before_sp1" }]
SELECT val FROM tx_t WHERE id = 5;
→ [{ "val": "after_sp1" }]

-- SAVEPOINT and ROLLBACK TO
BEGIN TRANSACTION;
UPDATE tx_t SET val = 'tx3_update' WHERE id = 1;
SAVEPOINT sp2;
INSERT INTO tx_t VALUES (6, 'after_sp2');
DELETE FROM tx_t WHERE id = 2;
SELECT count(*) FROM tx_t WHERE id = 6;
→ [{ "count(*)": 1 }]
SELECT count(*) FROM tx_t WHERE id = 2;
→ [{ "count(*)": 0 }]
ROLLBACK TO SAVEPOINT sp2;
-- Changes after sp2 are undone
SELECT count(*) FROM tx_t WHERE id = 6;
→ [{ "count(*)": 0 }]
SELECT count(*) FROM tx_t WHERE id = 2; -- Should be back
→ [{ "count(*)": 1 }]
SELECT val FROM tx_t WHERE id = 1; -- Update before sp2 remains
→ [{ "val": "tx3_update" }]
COMMIT;
SELECT val FROM tx_t WHERE id = 1;
→ [{ "val": "tx3_update" }]
SELECT count(*) FROM tx_t WHERE id = 6;
→ [{ "count(*)": 0 }]

-- Test nested savepoints (conceptual)
-- BEGIN;
-- INSERT INTO tx_t VALUES (100, 'a');
-- SAVEPOINT s1;
-- INSERT INTO tx_t VALUES (101, 'b');
-- SAVEPOINT s2;
-- INSERT INTO tx_t VALUES (102, 'c');
-- ROLLBACK TO s1;
-- SELECT count(*) FROM tx_t WHERE id > 99; -- Should be 1 (row 100)
-- → [{ "count(*)": 1 }]
-- COMMIT;

DROP TABLE tx_t;
