-- transactions.sqllogic - Testing BEGIN, COMMIT, ROLLBACK, SAVEPOINT, and implicit transactions

-- ===================================
-- Implicit Transaction Tests
-- ===================================
-- When not in an explicit transaction (autocommit mode), each statement
-- or batch of statements is automatically wrapped in an implicit transaction

CREATE TABLE implicit_tx (id INTEGER PRIMARY KEY, val TEXT);

-- Single statement should auto-commit
INSERT INTO implicit_tx VALUES (1, 'auto-committed');
SELECT val FROM implicit_tx WHERE id = 1;
→ [{ "val": "auto-committed" }]

-- Multiple statements in one exec should be atomic (all or nothing)
INSERT INTO implicit_tx VALUES (2, 'batch-a');
INSERT INTO implicit_tx VALUES (3, 'batch-b');
INSERT INTO implicit_tx VALUES (4, 'batch-c');
SELECT count(*) as cnt FROM implicit_tx;
→ [{ "cnt": 4 }]

-- Error in batch should rollback entire batch
-- This should fail on duplicate key and rollback both inserts
INSERT INTO implicit_tx VALUES (10, 'new1');
INSERT INTO implicit_tx VALUES (1, 'duplicate');
INSERT INTO implicit_tx VALUES (11, 'new2');
-- error: UNIQUE constraint failed

-- Verify the failed batch was rolled back (row 10 should not exist)
SELECT count(*) as cnt FROM implicit_tx WHERE id = 10;
→ [{ "cnt": 0 }]
SELECT count(*) as cnt FROM implicit_tx WHERE id = 11;
→ [{ "cnt": 0 }]

-- Original data should be intact
SELECT count(*) as cnt FROM implicit_tx;
→ [{ "cnt": 4 }]

DROP TABLE implicit_tx;

-- ===================================
-- Explicit Transaction Tests
-- ===================================

CREATE TABLE tx_t (id INTEGER PRIMARY KEY, val TEXT);
INSERT INTO tx_t VALUES (1, 'initial');

-- Basic COMMIT
BEGIN TRANSACTION;
INSERT INTO tx_t VALUES (2, 'tx1');
SELECT val FROM tx_t WHERE id = 2;
→ [{ "val": "tx1" }]
COMMIT;
SELECT val FROM tx_t WHERE id = 2;
→ [{ "val": "tx1" }]

-- Basic ROLLBACK
BEGIN TRANSACTION;
UPDATE tx_t SET val = 'tx2_update' WHERE id = 1;
INSERT INTO tx_t VALUES (3, 'tx2');
SELECT val FROM tx_t WHERE id = 1;
→ [{ "val": "tx2_update" }]
SELECT val FROM tx_t WHERE id = 3;
→ [{ "val": "tx2" }]
ROLLBACK;
SELECT val FROM tx_t WHERE id = 1;
→ [{ "val": "initial" }]
SELECT count(*) FROM tx_t WHERE id = 3;
→ [{ "count(*)": 0 }]

-- SAVEPOINT and RELEASE
BEGIN TRANSACTION;
INSERT INTO tx_t VALUES (4, 'before_sp1');
SAVEPOINT sp1;
INSERT INTO tx_t VALUES (5, 'after_sp1');
SELECT val FROM tx_t WHERE id = 5;
→ [{ "val": "after_sp1" }]
RELEASE SAVEPOINT sp1;
-- sp1 is now merged into the main transaction
COMMIT;
SELECT val FROM tx_t WHERE id = 4;
→ [{ "val": "before_sp1" }]
SELECT val FROM tx_t WHERE id = 5;
→ [{ "val": "after_sp1" }]

-- SAVEPOINT and ROLLBACK TO
BEGIN TRANSACTION;
UPDATE tx_t SET val = 'tx3_update' WHERE id = 1;
SAVEPOINT sp2;
INSERT INTO tx_t VALUES (6, 'after_sp2');
DELETE FROM tx_t WHERE id = 2;
SELECT count(*) FROM tx_t WHERE id = 6;
→ [{ "count(*)": 1 }]
SELECT count(*) FROM tx_t WHERE id = 2;
→ [{ "count(*)": 0 }]
ROLLBACK TO SAVEPOINT sp2;
-- Changes after sp2 are undone
SELECT count(*) FROM tx_t WHERE id = 6;
→ [{ "count(*)": 0 }]
SELECT count(*) FROM tx_t WHERE id = 2; -- Should be back
→ [{ "count(*)": 1 }]
SELECT val FROM tx_t WHERE id = 1; -- Update before sp2 remains
→ [{ "val": "tx3_update" }]
COMMIT;
SELECT val FROM tx_t WHERE id = 1;
→ [{ "val": "tx3_update" }]
SELECT count(*) FROM tx_t WHERE id = 6;
→ [{ "count(*)": 0 }]

-- ===================================
-- Nested Savepoints
-- ===================================
-- ROLLBACK TO s1 should discard s2 and everything after s1.

BEGIN;
INSERT INTO tx_t VALUES (100, 'a');
SAVEPOINT s1;
INSERT INTO tx_t VALUES (101, 'b');
SAVEPOINT s2;
INSERT INTO tx_t VALUES (102, 'c');
ROLLBACK TO s1;
SELECT count(*) FROM tx_t WHERE id > 99;
→ [{ "count(*)": 1 }]
COMMIT;

-- Verify after commit
SELECT count(*) FROM tx_t WHERE id >= 100;
→ [{ "count(*)": 1 }]
SELECT val FROM tx_t WHERE id = 100;
→ [{ "val": "a" }]

-- Clean up nested test data
DELETE FROM tx_t WHERE id >= 100;
-- run

-- ===================================
-- ROLLBACK TO non-existent savepoint (should error)
-- ===================================

BEGIN;
INSERT INTO tx_t VALUES (200, 'phantom');
ROLLBACK TO SAVEPOINT no_such_sp;
-- error: No such savepoint: no_such_sp

ROLLBACK;
-- run

-- ===================================
-- RELEASE non-existent savepoint (should error)
-- ===================================

BEGIN;
INSERT INTO tx_t VALUES (200, 'phantom');
RELEASE SAVEPOINT no_such_sp;
-- error: No such savepoint: no_such_sp

ROLLBACK;
-- run

-- ===================================
-- Same-prefix savepoint names (no collision)
-- ===================================

BEGIN;
SAVEPOINT sp;
INSERT INTO tx_t VALUES (300, 'sp-data');
SAVEPOINT spa;
INSERT INTO tx_t VALUES (301, 'spa-data');
ROLLBACK TO SAVEPOINT spa;
-- Only spa's changes are undone; sp's data remains
SELECT count(*) FROM tx_t WHERE id = 300;
→ [{ "count(*)": 1 }]
SELECT count(*) FROM tx_t WHERE id = 301;
→ [{ "count(*)": 0 }]
RELEASE SAVEPOINT spa;
RELEASE SAVEPOINT sp;
COMMIT;

-- Verify
SELECT val FROM tx_t WHERE id = 300;
→ [{ "val": "sp-data" }]

-- Clean up
DELETE FROM tx_t WHERE id >= 300;
-- run

-- ===================================
-- ROLLBACK TO preserves the savepoint (can release after rollback)
-- ===================================

BEGIN;
SAVEPOINT preserve_test;
INSERT INTO tx_t VALUES (400, 'will-be-undone');
ROLLBACK TO SAVEPOINT preserve_test;
-- Savepoint still exists; should be able to release it
RELEASE SAVEPOINT preserve_test;
COMMIT;

SELECT count(*) FROM tx_t WHERE id = 400;
→ [{ "count(*)": 0 }]

-- ===================================
-- Nested savepoints unwinding correctly
-- ===================================

BEGIN;
INSERT INTO tx_t VALUES (500, 'base');
SAVEPOINT sp_outer;
INSERT INTO tx_t VALUES (501, 'sp_outer');
SAVEPOINT sp_middle;
INSERT INTO tx_t VALUES (502, 'sp_middle');
SAVEPOINT sp_inner;
INSERT INTO tx_t VALUES (503, 'sp_inner');

-- Rollback to sp_middle should discard sp_inner and sp_middle's changes
ROLLBACK TO SAVEPOINT sp_middle;
SELECT count(*) FROM tx_t WHERE id = 503;
→ [{ "count(*)": 0 }]
SELECT count(*) FROM tx_t WHERE id = 502;
→ [{ "count(*)": 0 }]
-- sp_outer's insert and base should still be visible
SELECT count(*) FROM tx_t WHERE id = 501;
→ [{ "count(*)": 1 }]
SELECT count(*) FROM tx_t WHERE id = 500;
→ [{ "count(*)": 1 }]

RELEASE SAVEPOINT sp_middle;
RELEASE SAVEPOINT sp_outer;
COMMIT;

-- Verify final state
SELECT count(*) FROM tx_t WHERE id >= 500;
→ [{ "count(*)": 2 }]

DROP TABLE tx_t;
