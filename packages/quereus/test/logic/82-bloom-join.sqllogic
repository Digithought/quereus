-- bloom-join.sqllogic - Hash/bloom join algorithm correctness tests

-- Setup tables
CREATE TABLE bj_left (id INTEGER PRIMARY KEY, val INTEGER, label TEXT);
CREATE TABLE bj_right (id INTEGER PRIMARY KEY, val INTEGER, tag TEXT);

INSERT INTO bj_left VALUES (1, 10, 'a'), (2, 20, 'b'), (3, 30, 'c'), (4, 40, 'd'), (5, 10, 'e');
INSERT INTO bj_right VALUES (100, 10, 'x'), (200, 20, 'y'), (300, 50, 'z'), (400, 10, 'w');

-- Basic equi-join (should use bloom join for equi predicate)
SELECT l.id, r.id FROM bj_left l JOIN bj_right r ON l.val = r.val ORDER BY l.id, r.id;
→ [{"id":1,"id:1":100},{"id":1,"id:1":400},{"id":2,"id:1":200},{"id":5,"id:1":100},{"id":5,"id:1":400}]

-- Verify bloom join appears in plan
SELECT 1 AS ok FROM query_plan('SELECT * FROM bj_left l JOIN bj_right r ON l.val = r.val')
WHERE properties LIKE '%bloom%' LIMIT 1;
→ [{"ok":1}]

-- LEFT JOIN with bloom join
SELECT l.id, l.val, r.tag FROM bj_left l LEFT JOIN bj_right r ON l.val = r.val ORDER BY l.id, r.tag;
→ [{"id":1,"val":10,"tag":"w"},{"id":1,"val":10,"tag":"x"},{"id":2,"val":20,"tag":"y"},{"id":3,"val":30,"tag":null},{"id":4,"val":40,"tag":null},{"id":5,"val":10,"tag":"w"},{"id":5,"val":10,"tag":"x"}]

-- Multi-column equi-join
CREATE TABLE bj_mc1 (a INTEGER, b INTEGER, v TEXT, PRIMARY KEY (a, b));
CREATE TABLE bj_mc2 (x INTEGER, y INTEGER, w TEXT, PRIMARY KEY (x, y));

INSERT INTO bj_mc1 VALUES (1, 10, 'alpha'), (2, 20, 'beta'), (3, 30, 'gamma');
INSERT INTO bj_mc2 VALUES (1, 10, 'one'), (2, 20, 'two'), (9, 99, 'nine');

SELECT m1.v, m2.w FROM bj_mc1 m1 JOIN bj_mc2 m2 ON m1.a = m2.x AND m1.b = m2.y ORDER BY m1.a;
→ [{"v":"alpha","w":"one"},{"v":"beta","w":"two"}]

-- NULL handling: NULLs should not match
CREATE TABLE bj_nulls (id INTEGER PRIMARY KEY, val INTEGER NULL);
INSERT INTO bj_nulls VALUES (1, null), (2, 10), (3, null), (4, 10);

SELECT a.id, b.id FROM bj_nulls a JOIN bj_nulls b ON a.val = b.val ORDER BY a.id, b.id;
→ [{"id":2,"id:1":2},{"id":2,"id:1":4},{"id":4,"id:1":2},{"id":4,"id:1":4}]

-- NULL LEFT JOIN: null keys produce unmatched rows
SELECT a.id, b.id FROM bj_nulls a LEFT JOIN bj_nulls b ON a.val = b.val ORDER BY a.id, b.id;
→ [{"id":1,"id:1":null},{"id":2,"id:1":2},{"id":2,"id:1":4},{"id":3,"id:1":null},{"id":4,"id:1":2},{"id":4,"id:1":4}]

-- Empty right side
CREATE TABLE bj_empty (id INTEGER PRIMARY KEY, val INTEGER);

SELECT l.id FROM bj_left l JOIN bj_empty e ON l.val = e.val;
→ []

SELECT l.id, e.id FROM bj_left l LEFT JOIN bj_empty e ON l.val = e.val ORDER BY l.id;
→ [{"id":1,"id:1":null},{"id":2,"id:1":null},{"id":3,"id:1":null},{"id":4,"id:1":null},{"id":5,"id:1":null}]

-- Empty left side
SELECT e.id FROM bj_empty e JOIN bj_right r ON e.val = r.val;
→ []

-- Type-mixed join columns: integer = integer is standard; also test with text
CREATE TABLE bj_text_l (id INTEGER PRIMARY KEY, key TEXT);
CREATE TABLE bj_text_r (id INTEGER PRIMARY KEY, key TEXT);
INSERT INTO bj_text_l VALUES (1, 'foo'), (2, 'bar'), (3, 'baz');
INSERT INTO bj_text_r VALUES (10, 'bar'), (20, 'baz'), (30, 'qux');

SELECT l.id, r.id FROM bj_text_l l JOIN bj_text_r r ON l.key = r.key ORDER BY l.id;
→ [{"id":2,"id:1":10},{"id":3,"id:1":20}]

-- USING clause should also use bloom join
SELECT l.id, r.id FROM bj_text_l l JOIN bj_text_r r USING (key) ORDER BY l.id;
→ [{"id":2,"id:1":10},{"id":3,"id:1":20}]

-- Duplicate key runs: multiple matches on both sides
CREATE TABLE bj_dup_l (id INTEGER PRIMARY KEY, val INTEGER);
CREATE TABLE bj_dup_r (id INTEGER PRIMARY KEY, val INTEGER);
INSERT INTO bj_dup_l VALUES (1, 5), (2, 5), (3, 5);
INSERT INTO bj_dup_r VALUES (10, 5), (20, 5);

SELECT count(*) AS cnt FROM bj_dup_l l JOIN bj_dup_r r ON l.val = r.val;
→ [{"cnt":6}]

-- Cleanup
DROP TABLE bj_left;
DROP TABLE bj_right;
DROP TABLE bj_mc1;
DROP TABLE bj_mc2;
DROP TABLE bj_nulls;
DROP TABLE bj_empty;
DROP TABLE bj_text_l;
DROP TABLE bj_text_r;
DROP TABLE bj_dup_l;
DROP TABLE bj_dup_r;
