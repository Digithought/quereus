-- bloom-join.sqllogic - Hash/bloom join algorithm correctness tests

-- Setup tables
CREATE TABLE bj_left (id INTEGER PRIMARY KEY, val INTEGER, label TEXT);
CREATE TABLE bj_right (id INTEGER PRIMARY KEY, val INTEGER, tag TEXT);

INSERT INTO bj_left VALUES (1, 10, 'a'), (2, 20, 'b'), (3, 30, 'c'), (4, 40, 'd'), (5, 10, 'e');
INSERT INTO bj_right VALUES (100, 10, 'x'), (200, 20, 'y'), (300, 50, 'z'), (400, 10, 'w');

-- Basic equi-join (should use bloom join for equi predicate)
SELECT l.id, r.id FROM bj_left l JOIN bj_right r ON l.val = r.val ORDER BY l.id, r.id;
→ [{"id":1,"id:1":100},{"id":1,"id:1":400},{"id":2,"id:1":200},{"id":5,"id:1":100},{"id":5,"id:1":400}]

-- Verify bloom join appears in plan
SELECT 1 AS ok FROM query_plan('SELECT * FROM bj_left l JOIN bj_right r ON l.val = r.val')
WHERE properties LIKE '%bloom%' LIMIT 1;
→ [{"ok":1}]

-- LEFT JOIN with bloom join
SELECT l.id, l.val, r.tag FROM bj_left l LEFT JOIN bj_right r ON l.val = r.val ORDER BY l.id, r.tag;
→ [{"id":1,"val":10,"tag":"w"},{"id":1,"val":10,"tag":"x"},{"id":2,"val":20,"tag":"y"},{"id":3,"val":30,"tag":null},{"id":4,"val":40,"tag":null},{"id":5,"val":10,"tag":"w"},{"id":5,"val":10,"tag":"x"}]

-- Multi-column equi-join
CREATE TABLE bj_mc1 (a INTEGER, b INTEGER, v TEXT, PRIMARY KEY (a, b));
CREATE TABLE bj_mc2 (x INTEGER, y INTEGER, w TEXT, PRIMARY KEY (x, y));

INSERT INTO bj_mc1 VALUES (1, 10, 'alpha'), (2, 20, 'beta'), (3, 30, 'gamma');
INSERT INTO bj_mc2 VALUES (1, 10, 'one'), (2, 20, 'two'), (9, 99, 'nine');

SELECT m1.v, m2.w FROM bj_mc1 m1 JOIN bj_mc2 m2 ON m1.a = m2.x AND m1.b = m2.y ORDER BY m1.a;
→ [{"v":"alpha","w":"one"},{"v":"beta","w":"two"}]

-- NULL handling: NULLs should not match
CREATE TABLE bj_nulls (id INTEGER PRIMARY KEY, val INTEGER NULL);
INSERT INTO bj_nulls VALUES (1, null), (2, 10), (3, null), (4, 10);

SELECT a.id, b.id FROM bj_nulls a JOIN bj_nulls b ON a.val = b.val ORDER BY a.id, b.id;
→ [{"id":2,"id:1":2},{"id":2,"id:1":4},{"id":4,"id:1":2},{"id":4,"id:1":4}]

-- NULL LEFT JOIN: null keys produce unmatched rows
SELECT a.id, b.id FROM bj_nulls a LEFT JOIN bj_nulls b ON a.val = b.val ORDER BY a.id, b.id;
→ [{"id":1,"id:1":null},{"id":2,"id:1":2},{"id":2,"id:1":4},{"id":3,"id:1":null},{"id":4,"id:1":2},{"id":4,"id:1":4}]

-- Empty right side
CREATE TABLE bj_empty (id INTEGER PRIMARY KEY, val INTEGER);

SELECT l.id FROM bj_left l JOIN bj_empty e ON l.val = e.val;
→ []

SELECT l.id, e.id FROM bj_left l LEFT JOIN bj_empty e ON l.val = e.val ORDER BY l.id;
→ [{"id":1,"id:1":null},{"id":2,"id:1":null},{"id":3,"id:1":null},{"id":4,"id:1":null},{"id":5,"id:1":null}]

-- Empty left side
SELECT e.id FROM bj_empty e JOIN bj_right r ON e.val = r.val;
→ []

-- Type-mixed join columns: integer = integer is standard; also test with text
CREATE TABLE bj_text_l (id INTEGER PRIMARY KEY, key TEXT);
CREATE TABLE bj_text_r (id INTEGER PRIMARY KEY, key TEXT);
INSERT INTO bj_text_l VALUES (1, 'foo'), (2, 'bar'), (3, 'baz');
INSERT INTO bj_text_r VALUES (10, 'bar'), (20, 'baz'), (30, 'qux');

SELECT l.id, r.id FROM bj_text_l l JOIN bj_text_r r ON l.key = r.key ORDER BY l.id;
→ [{"id":2,"id:1":10},{"id":3,"id:1":20}]

-- USING clause should also use bloom join
SELECT l.id, r.id FROM bj_text_l l JOIN bj_text_r r USING (key) ORDER BY l.id;
→ [{"id":2,"id:1":10},{"id":3,"id:1":20}]

-- Duplicate key runs: multiple matches on both sides
CREATE TABLE bj_dup_l (id INTEGER PRIMARY KEY, val INTEGER);
CREATE TABLE bj_dup_r (id INTEGER PRIMARY KEY, val INTEGER);
INSERT INTO bj_dup_l VALUES (1, 5), (2, 5), (3, 5);
INSERT INTO bj_dup_r VALUES (10, 5), (20, 5);

SELECT count(*) AS cnt FROM bj_dup_l l JOIN bj_dup_r r ON l.val = r.val;
→ [{"cnt":6}]

-- LEFT JOIN with small left, large right: left must remain probe side
-- (regression: side-swap must not apply to LEFT JOINs)
CREATE TABLE bj_small (id INTEGER PRIMARY KEY, val INTEGER);
CREATE TABLE bj_large (id INTEGER PRIMARY KEY, val INTEGER);
INSERT INTO bj_small VALUES (1, 100), (2, 200);
INSERT INTO bj_large VALUES (10, 100), (20, 100), (30, 300), (40, 400), (50, 500), (60, 600), (70, 700);

-- All rows from bj_small must appear; unmatched get null right side
SELECT s.id, s.val, l.id AS lid FROM bj_small s LEFT JOIN bj_large l ON s.val = l.val ORDER BY s.id, l.id;
→ [{"id":1,"val":100,"lid":10},{"id":1,"val":100,"lid":20},{"id":2,"val":200,"lid":null}]

-- NOCASE collation: bloom join must normalize keys for case-insensitive matching
CREATE TABLE bj_nocase_l (id INTEGER PRIMARY KEY, name TEXT COLLATE NOCASE);
CREATE TABLE bj_nocase_r (id INTEGER PRIMARY KEY, name TEXT COLLATE NOCASE);
INSERT INTO bj_nocase_l VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO bj_nocase_r VALUES (10, 'alice'), (20, 'BOB'), (30, 'Dave');

SELECT l.id, r.id FROM bj_nocase_l l JOIN bj_nocase_r r ON l.name = r.name ORDER BY l.id;
→ [{"id":1,"id:1":10},{"id":2,"id:1":20}]

-- NOCASE LEFT JOIN: unmatched probe rows still appear
SELECT l.id, l.name, r.id AS rid FROM bj_nocase_l l LEFT JOIN bj_nocase_r r ON l.name = r.name ORDER BY l.id;
→ [{"id":1,"name":"Alice","rid":10},{"id":2,"name":"Bob","rid":20},{"id":3,"name":"Charlie","rid":null}]

-- Cleanup
DROP TABLE bj_left;
DROP TABLE bj_right;
DROP TABLE bj_mc1;
DROP TABLE bj_mc2;
DROP TABLE bj_nulls;
DROP TABLE bj_empty;
DROP TABLE bj_text_l;
DROP TABLE bj_text_r;
DROP TABLE bj_dup_l;
DROP TABLE bj_dup_r;
DROP TABLE bj_small;
DROP TABLE bj_large;
DROP TABLE bj_nocase_l;
DROP TABLE bj_nocase_r;
