-- utilities.sqllogic - Edge cases for NULL handling, coercion, collation, truthiness, and aggregates

-- === NULL comparison semantics ===

select null = null;
→ [{"null = null":null}]

select null < 1;
→ [{"null < 1":null}]

select null > 1;
→ [{"null > 1":null}]

select null != null;
→ [{"null != null":null}]

select null >= 0;
→ [{"null >= 0":null}]

-- === NULL sorting (total ordering: NULL first in ASC by default) ===

CREATE TABLE null_sort_t (id INTEGER PRIMARY KEY, v INTEGER NULL);
INSERT INTO null_sort_t VALUES (1, null), (2, 3), (3, 1), (4, null), (5, 2);

select v from null_sort_t order by v;
→ [{"v":null},{"v":null},{"v":1},{"v":2},{"v":3}]

select v from null_sort_t order by v desc;
→ [{"v":null},{"v":null},{"v":3},{"v":2},{"v":1}]

-- NULLS LAST moves nulls to end in ASC
select v from null_sort_t order by v nulls last;
→ [{"v":1},{"v":2},{"v":3},{"v":null},{"v":null}]

-- NULLS FIRST in DESC keeps nulls at the start (same as default DESC)
select v from null_sort_t order by v desc nulls first;
→ [{"v":3},{"v":2},{"v":1},{"v":null},{"v":null}]

DROP TABLE null_sort_t;

-- === Storage class ordering ===
-- Type ordering: NULL < NUMERIC < TEXT < BLOB

CREATE TABLE mixed_t (id INTEGER PRIMARY KEY, v ANY NULL);
INSERT INTO mixed_t VALUES (1, null), (2, 42), (3, 'hello'), (4, 3.14), (5, x'FF');

-- Verify cross-type ordering via typeof
select typeof(v) from mixed_t order by v;
→ [{"typeof(v)":"null"},{"typeof(v)":"real"},{"typeof(v)":"integer"},{"typeof(v)":"text"},{"typeof(v)":"blob"}]

DROP TABLE mixed_t;

-- === Collation tests ===

-- Default (BINARY) collation: case-sensitive
select 'ABC' = 'abc';
→ [{"'ABC' = 'abc'":false}]

-- NOCASE collation on column definition
CREATE TABLE nocase_t (id INTEGER PRIMARY KEY, name TEXT COLLATE NOCASE);
INSERT INTO nocase_t VALUES (1, 'Alice'), (2, 'alice'), (3, 'BOB'), (4, 'bob');

-- Case-insensitive ordering (secondary sort by id for stability)
select name from nocase_t order by name, id;
→ [{"name":"Alice"},{"name":"alice"},{"name":"BOB"},{"name":"bob"}]

-- Case-insensitive equality
select id from nocase_t where name = 'alice' order by id;
→ [{"id":1},{"id":2}]

DROP TABLE nocase_t;

-- RTRIM collation on column definition
CREATE TABLE rtrim_t (id INTEGER PRIMARY KEY, name TEXT COLLATE RTRIM);
INSERT INTO rtrim_t VALUES (1, 'hello'), (2, 'hello   '), (3, 'world'), (4, 'world ');

-- RTRIM equality: 'hello' and 'hello   ' are equal
select id from rtrim_t where name = 'hello' order by id;
→ [{"id":1},{"id":2}]

select id from rtrim_t where name = 'world' order by id;
→ [{"id":3},{"id":4}]

DROP TABLE rtrim_t;

-- === Coercion edge cases ===

-- Numeric string coercion in comparisons
select 42 = '42';
→ [{"42 = '42'":true}]

select 42 < '43';
→ [{"42 < '43'":true}]

-- Non-numeric string stays as text (cross-type comparison: number != text)
select 42 = 'hello';
→ [{"42 = 'hello'":false}]

-- Scientific notation coercion
select 1000 = '1e3';
→ [{"1000 = '1e3'":true}]

-- Arithmetic with mixed types
select 1 + '2';
→ [{"1 + '2'":3}]

-- Non-numeric string coerces to 0 in arithmetic
select 1 + 'hello';
→ [{"1 + 'hello'":1}]

select 'abc' + 0;
→ [{"'abc' + 0":0}]

select '' + 0;
→ [{"'' + 0":0}]

-- === Truthiness (isTruthy) edge cases ===

CREATE TABLE bool_t (id INTEGER PRIMARY KEY, v ANY NULL);
INSERT INTO bool_t VALUES (1, 0), (2, 1), (3, ''), (4, 'text'), (5, null);

-- WHERE uses numeric truthiness: strings are coerced to numbers; non-numeric strings are falsy
select id from bool_t where v;
→ [{"id":2}]

DROP TABLE bool_t;

-- CASE WHEN uses isTruthy
select case when 0 then 'yes' else 'no' end as r;
→ [{"r":"no"}]

select case when 1 then 'yes' else 'no' end as r;
→ [{"r":"yes"}]

select case when '' then 'yes' else 'no' end as r;
→ [{"r":"no"}]

select case when 'nonempty' then 'yes' else 'no' end as r;
→ [{"r":"no"}]

select case when null then 'yes' else 'no' end as r;
→ [{"r":"no"}]

-- === Aggregate coercion ===

-- SUM with numeric strings (coerced to numbers)
CREATE TABLE agg_t (id INTEGER PRIMARY KEY, amount TEXT);
INSERT INTO agg_t VALUES (1, '10'), (2, '20'), (3, '30');

select sum(amount) from agg_t;
→ [{"sum(amount)":60}]

-- MIN/MAX with mixed coerced values
-- Numeric strings are coerced to numbers; non-numeric stay as text
-- Storage class ordering: NUMERIC < TEXT, so min = smallest number, max = largest text
INSERT INTO agg_t VALUES (4, 'z'), (5, 'a');

select min(amount) from agg_t;
→ [{"min(amount)":10}]

select max(amount) from agg_t;
→ [{"max(amount)":"z"}]

DROP TABLE agg_t;
