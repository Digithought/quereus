-- builtin_functions.sqllogic - Testing various built-in functions

-- Scalar Functions
SELECT lower('Quereus'), upper('Quereus'), length('Quereus');
→ [{"lower('Quereus')":"quereus","upper('Quereus')":"QUEREUS","length('Quereus')":7}]
SELECT substr('Quereus', 2, 3), substring('Quereus', 4);
→ [{"substr('Quereus', 2, 3)":"uer","substring('Quereus', 4)":"reus"}]
SELECT abs(-10), round(12.345, 1), round(12.345);
→ [{"abs(-10)":10,"round(12.345, 1)":12.3,"round(12.345)":12}]
SELECT typeof(1), typeof(1.5), typeof('text'), typeof(x'01'), typeof(null), typeof(12345678901234567890);
→ [{"typeof(1)":"integer","typeof(1.5)":"real","typeof('text')":"text","typeof(x'01')":"blob","typeof(null)":"null","typeof(12345678901234567890)":"integer"}]
SELECT like('abc%', 'abcde'), glob('a*c', 'abbbc');
→ [{"like('abc%', 'abcde')":1,"glob('a*c', 'abbbc')":1}]

-- LIKE Operator Tests
PRAGMA default_vtab_module='memory';
CREATE TABLE like_test (id INT, name TEXT);
INSERT INTO like_test VALUES (1, 'apple'), (2, 'berry'), (3, 'citrus'), (4, 'orange');

-- Test basic LIKE operator
SELECT * FROM like_test WHERE name LIKE 'a%' ORDER BY id;
→ [{"id":1,"name":"apple"}]

-- Test NOT LIKE operator
SELECT * FROM like_test WHERE name NOT LIKE '%a%' ORDER BY id;
→ [{"id":2,"name":"berry"},{"id":3,"name":"citrus"}]

-- Test underscore wildcard
SELECT * FROM like_test WHERE name LIKE '_ra%' ORDER BY id;
→ [{"id":4,"name":"orange"}]

-- Test literal matching
SELECT * FROM like_test WHERE name LIKE 'apple';
→ [{"id":1,"name":"apple"}]

-- Test LIKE with NULL
SELECT * FROM like_test WHERE NULL LIKE 'a%';
→ []

-- Test pattern with NULL
SELECT * FROM like_test WHERE 'apple' LIKE NULL;
→ []

DROP TABLE like_test;

-- Date/Time Functions (output format depends on default build)
SELECT date('now') IS NOT NULL;
→ [1]
SELECT time('now') IS NOT NULL;
→ [1]
SELECT datetime('now') IS NOT NULL;
→ [1]
SELECT julianday('2024-01-01') - julianday('2023-01-01');
→ [365]
SELECT strftime('%Y-%m-%d', '2024-07-26');
→ ["2024-07-26"]

-- ISO Validation Functions
SELECT IsISODate('2024-02-29'), IsISODate('2023-02-29'), IsISODate('2024-13-01'), IsISODate('2024-01-32'), IsISODate('2024-01-01'), IsISODate(NULL);
→ [{"isisodate('2024-02-29')":1,"isisodate('2023-02-29')":0,"isisodate('2024-13-01')":0,"isisodate('2024-01-32')":0,"isisodate('2024-01-01')":1,"isisodate(null)":0}]
SELECT IsISODateTime('2024-01-01T00:00'), IsISODateTime('2024-01-01T00:00:00Z'), IsISODateTime('2024-01-01T23:59:59+05:30'), IsISODateTime('2024-01-01 00:00:00'), IsISODateTime('2024-01-01T24:00');
→ [{"isisodatetime('2024-01-01T00:00')":1,"isisodatetime('2024-01-01T00:00:00Z')":1,"isisodatetime('2024-01-01T23:59:59+05:30')":1,"isisodatetime('2024-01-01 00:00:00')":0,"isisodatetime('2024-01-01T24:00')":0}]
SELECT IsISODateTime('2024-01-01T10:00:00.123456789'), IsISODateTime('2024-01-01T10:00:00.1234567890');
→ [{"isisodatetime('2024-01-01T10:00:00.123456789')":1,"isisodatetime('2024-01-01T10:00:00.1234567890')":0}]

-- JSON Functions
SELECT json_valid('{"a": 1}'), json_valid('{');
→ [{"json_valid('{\"a\": 1}')":1,"json_valid('{')":0}]
SELECT json_type('{"a": 1}', '$.a'), json_type('[1, "t", null]', '[1]');
→ [{"json_type('{\"a\": 1}', '$.a')":"integer","json_type('[1, \"t\", null]', '[1]')":"text"}]
SELECT json_extract('{"a": [10, 20], "b": "foo"}', '$.a[1]');
→ [20]
SELECT json_quote(1), json_quote('text'), json_quote(null);
→ [{"json_quote(1)":"1","json_quote('text')":"\"text\"","json_quote(null)":"null"}]
SELECT json_array(1, 'two', null, json_object('x', 3));
→ ["[1,\"two\",null,{\"x\":3}]"]
SELECT json_object('a', 1, 'b', json_array(2, 3));
→ ["{\"a\":1,\"b\":[2,3]}"]
SELECT json_insert('{"a":1}', '$.b', 2);
→ ["{\"a\":1,\"b\":2}"]
SELECT json_replace('{"a":1, "b":2}', '$.a', 99);
→ ["{\"a\":99,\"b\":2}"]
SELECT json_set('{"a":1}', '$.a', 99, '$.c', 'new');
→ ["{\"a\":99,\"c\":\"new\"}"]
SELECT json_remove('{"a":1, "b":[2,3]}', '$.b[0]');
→ ["{\"a\":1,\"b\":[3]}"]
SELECT json_array_length('[1, 2, 3]');
→ [3]

-- JSON Schema Validation
-- Basic type validation
SELECT json_schema('42', 'integer'), json_schema('42', 'number'), json_schema('42.5', 'integer'), json_schema('42.5', 'number');
→ [{"json_schema('42', 'integer')":1,"json_schema('42', 'number')":1,"json_schema('42.5', 'integer')":0,"json_schema('42.5', 'number')":1}]
SELECT json_schema('"hello"', 'string'), json_schema('true', 'boolean'), json_schema('null', 'null');
→ [{"json_schema('\"hello\"', 'string')":1,"json_schema('true', 'boolean')":1,"json_schema('null', 'null')":1}]

-- Array validation
SELECT json_schema('[1, 2, 3]', '[integer]'), json_schema('[1, 2.5, 3]', '[integer]');
→ [{"json_schema('[1, 2, 3]', '[integer]')":1,"json_schema('[1, 2.5, 3]', '[integer]')":0}]
SELECT json_schema('["a", "b", "c"]', '[string]'), json_schema('[1, "mixed"]', '[integer]');
→ [{"json_schema('[\"a\", \"b\", \"c\"]', '[string]')":1,"json_schema('[1, \"mixed\"]', '[integer]')":0}]

-- Object validation
SELECT json_schema('{"x": 42}', '{x:integer}'), json_schema('{"x": 42, "y": 3.14}', '{x:integer,y:number}');
→ [{"json_schema('{\"x\": 42}', '{x:integer}')":1,"json_schema('{\"x\": 42, \"y\": 3.14}', '{x:integer,y:number}')":1}]
SELECT json_schema('{"x": "wrong"}', '{x:integer}'), json_schema('{"x": 42}', '{x:integer,y:number}');
→ [{"json_schema('{\"x\": \"wrong\"}', '{x:integer}')":0,"json_schema('{\"x\": 42}', '{x:integer,y:number}')":0}]

-- Nested structures - array of objects
SELECT json_schema('[{"x": 1}, {"x": 2}]', '[{x:integer}]'), json_schema('[{"x": 1}, {"x": "wrong"}]', '[{x:integer}]');
→ [{"json_schema('[{\"x\": 1}, {\"x\": 2}]', '[{x:integer}]')":1,"json_schema('[{\"x\": 1}, {\"x\": \"wrong\"}]', '[{x:integer}]')":0}]

-- Nested structures - object with arrays
SELECT json_schema('{"items": [1, 2, 3]}', '{items:[integer]}'), json_schema('{"items": [1, "wrong", 3]}', '{items:[integer]}');
→ [{"json_schema('{\"items\": [1, 2, 3]}', '{items:[integer]}')":1,"json_schema('{\"items\": [1, \"wrong\", 3]}', '{items:[integer]}')":0}]

-- Complex nested structure
SELECT json_schema('{"users": [{"name": "Alice", "age": 30}, {"name": "Bob", "age": 25}]}', '{users:[{name:string,age:integer}]}'), json_schema('{"users": [{"name": "Alice", "age": "thirty"}]}', '{users:[{name:string,age:integer}]}');
→ [{"json_schema('{\"users\": [{\"name\": \"Alice\", \"age\": 30}, {\"name\": \"Bob\", \"age\": 25}]}', '{users:[{name:string,age:integer}]}')":1,"json_schema('{\"users\": [{\"name\": \"Alice\", \"age\": \"thirty\"}]}', '{users:[{name:string,age:integer}]}')":0}]

-- Invalid JSON and schema
SELECT json_schema('{invalid', 'integer'), json_schema('42', 'unknown_type');
→ [{"json_schema('{invalid', 'integer')":0,"json_schema('42', 'unknown_type')":0}]

-- Empty structures
SELECT json_schema('[]', '[integer]'), json_schema('{}', '{x:integer}'), json_schema('{}', '{}');
→ [{"json_schema('[]', '[integer]')":1,"json_schema('{}', '{x:integer}')":0,"json_schema('{}', '{}')":1}]

-- Use in CHECK constraint
PRAGMA default_vtab_module='memory';
CREATE TABLE events (
  id INTEGER PRIMARY KEY,
  data JSON CHECK (json_schema(data, '[{x:integer}]'))
);
INSERT INTO events VALUES (1, '[{"x": 1}, {"x": 2}]');
SELECT * FROM events;
→ [{"id":1,"data":"[{\"x\":1},{\"x\":2}]"}]
INSERT INTO events VALUES (2, '[{"x": "wrong"}]');
-- error: CHECK constraint failed
SELECT * FROM events;
→ [{"id":1,"data":"[{\"x\":1},{\"x\":2}]"}]
DROP TABLE events;

-- Aggregate JSON Functions (Need table context)
PRAGMA default_vtab_module='memory';
CREATE TABLE json_agg_t (id INT, grp TEXT, val TEXT);
INSERT INTO json_agg_t VALUES (1, 'A', '1'), (2, 'B', 'x'), (3, 'A', '2'), (4, 'B', 'y');
SELECT grp, json_group_array(val) FROM json_agg_t GROUP BY grp ORDER BY grp;
→ [{"grp":"A","json_group_array(val)":"[1,2]"},{"grp":"B","json_group_array(val)":"[\"x\",\"y\"]"}]
SELECT grp, json_group_object(val, id) FROM (SELECT * FROM json_agg_t) GROUP BY grp ORDER BY grp;
→ [{"grp":"A","json_group_object(val, id)":"{\"1\":1,\"2\":3}"},{"grp":"B","json_group_object(val, id)":"{\"x\":2,\"y\":4}"}]
DROP TABLE json_agg_t;
