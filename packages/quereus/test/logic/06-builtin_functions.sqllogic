-- builtin_functions.sqllogic - Testing various built-in functions

-- Scalar Functions
SELECT lower('Quereus'), upper('Quereus'), length('Quereus');
→ [{"lower('Quereus')":"quereus","upper('Quereus')":"QUEREUS","length('Quereus')":7}]
SELECT substr('Quereus', 2, 3), substring('Quereus', 4);
→ [{"substr('Quereus', 2, 3)":"uer","substring('Quereus', 4)":"reus"}]
SELECT abs(-10), round(12.345, 1), round(12.345);
→ [{"abs(-10)":10,"round(12.345, 1)":12.3,"round(12.345)":12}]
SELECT typeof(1), typeof(1.5), typeof('text'), typeof(x'01'), typeof(null), typeof(12345678901234567890);
→ [{"typeof(1)":"integer","typeof(1.5)":"real","typeof('text')":"text","typeof(x'01')":"blob","typeof(null)":"null","typeof(12345678901234567890)":"integer"}]
SELECT like('abc%', 'abcde'), glob('a*c', 'abbbc');
→ [{"like('abc%', 'abcde')":true,"glob('a*c', 'abbbc')":true}]

-- LIKE Operator Tests
PRAGMA default_vtab_module='memory';
CREATE TABLE like_test (id INT, name TEXT);
INSERT INTO like_test VALUES (1, 'apple'), (2, 'berry'), (3, 'citrus'), (4, 'orange');

-- Test basic LIKE operator
SELECT * FROM like_test WHERE name LIKE 'a%' ORDER BY id;
→ [{"id":1,"name":"apple"}]

-- Test NOT LIKE operator
SELECT * FROM like_test WHERE name NOT LIKE '%a%' ORDER BY id;
→ [{"id":2,"name":"berry"},{"id":3,"name":"citrus"}]

-- Test underscore wildcard
SELECT * FROM like_test WHERE name LIKE '_ra%' ORDER BY id;
→ [{"id":4,"name":"orange"}]

-- Test literal matching
SELECT * FROM like_test WHERE name LIKE 'apple';
→ [{"id":1,"name":"apple"}]

-- Test LIKE with NULL
SELECT * FROM like_test WHERE NULL LIKE 'a%';
→ []

-- Test pattern with NULL
SELECT * FROM like_test WHERE 'apple' LIKE NULL;
→ []

DROP TABLE like_test;

-- Date/Time Functions (output format depends on default build)
SELECT date('now') IS NOT NULL;
→ [true]
SELECT time('now') IS NOT NULL;
→ [true]
SELECT datetime('now') IS NOT NULL;
→ [true]
SELECT julianday('2024-01-01') - julianday('2023-01-01');
→ [365]
SELECT strftime('%Y-%m-%d', '2024-07-26');
→ ["2024-07-26"]

-- ISO Validation Functions
SELECT IsISODate('2024-02-29'), IsISODate('2023-02-29'), IsISODate('2024-13-01'), IsISODate('2024-01-32'), IsISODate('2024-01-01'), IsISODate(NULL);
→ [{"isisodate('2024-02-29')":true,"isisodate('2023-02-29')":false,"isisodate('2024-13-01')":false,"isisodate('2024-01-32')":false,"isisodate('2024-01-01')":true,"isisodate(null)":false}]
SELECT IsISODateTime('2024-01-01T00:00'), IsISODateTime('2024-01-01T00:00:00Z'), IsISODateTime('2024-01-01T23:59:59+05:30'), IsISODateTime('2024-01-01 00:00:00'), IsISODateTime('2024-01-01T24:00');
→ [{"isisodatetime('2024-01-01T00:00')":true,"isisodatetime('2024-01-01T00:00:00Z')":true,"isisodatetime('2024-01-01T23:59:59+05:30')":true,"isisodatetime('2024-01-01 00:00:00')":false,"isisodatetime('2024-01-01T24:00')":false}]
SELECT IsISODateTime('2024-01-01T10:00:00.123456789'), IsISODateTime('2024-01-01T10:00:00.1234567890');
→ [{"isisodatetime('2024-01-01T10:00:00.123456789')":true,"isisodatetime('2024-01-01T10:00:00.1234567890')":false}]

-- JSON Functions
SELECT json_valid('{"a": 1}'), json_valid('{');
→ [{"json_valid('{\"a\": 1}')":true,"json_valid('{')":false}]
SELECT json_type('{"a": 1}', '$.a'), json_type('[1, "t", null]', '[1]');
→ [{"json_type('{\"a\": 1}', '$.a')":"integer","json_type('[1, \"t\", null]', '[1]')":"text"}]
SELECT json_extract('{"a": [10, 20], "b": "foo"}', '$.a[1]');
→ [20]
SELECT json_quote(1), json_quote('text'), json_quote(null);
→ [{"json_quote(1)":"1","json_quote('text')":"\"text\"","json_quote(null)":"null"}]
SELECT json_array(1, 'two', null, json_object('x', 3));
→ ["[1,\"two\",null,{\"x\":3}]"]
SELECT json_object('a', 1, 'b', json_array(2, 3));
→ ["{\"a\":1,\"b\":[2,3]}"]
SELECT json_insert('{"a":1}', '$.b', 2);
→ ["{\"a\":1,\"b\":2}"]
SELECT json_replace('{"a":1, "b":2}', '$.a', 99);
→ ["{\"a\":99,\"b\":2}"]
SELECT json_set('{"a":1}', '$.a', 99, '$.c', 'new');
→ ["{\"a\":99,\"c\":\"new\"}"]
SELECT json_remove('{"a":1, "b":[2,3]}', '$.b[0]');
→ ["{\"a\":1,\"b\":[3]}"]
SELECT json_array_length('[1, 2, 3]');
→ [3]

-- JSON Schema Validation (using moat-maker TypeScript-like syntax)
-- Basic type validation
SELECT json_schema('42', 'number'), json_schema('42.5', 'number');
→ [{"json_schema('42', 'number')":true,"json_schema('42.5', 'number')":true}]
SELECT json_schema('"hello"', 'string'), json_schema('true', 'boolean'), json_schema('null', 'null');
→ [{"json_schema('\"hello\"', 'string')":true,"json_schema('true', 'boolean')":true,"json_schema('null', 'null')":true}]

-- Array validation
SELECT json_schema('[1, 2, 3]', 'number[]'), json_schema('[1, 2.5, 3]', 'number[]');
→ [{"json_schema('[1, 2, 3]', 'number[]')":true,"json_schema('[1, 2.5, 3]', 'number[]')":true}]
SELECT json_schema('["a", "b", "c"]', 'string[]'), json_schema('[1, "mixed"]', 'number[]');
→ [{"json_schema('[\"a\", \"b\", \"c\"]', 'string[]')":true,"json_schema('[1, \"mixed\"]', 'number[]')":false}]

-- Object validation
SELECT json_schema('{"x": 42}', '{ x: number }'), json_schema('{"x": 42, "y": 3.14}', '{ x: number, y: number }');
→ [{"json_schema('{\"x\": 42}', '{ x: number }')":true,"json_schema('{\"x\": 42, \"y\": 3.14}', '{ x: number, y: number }')":true}]
SELECT json_schema('{"x": "wrong"}', '{ x: number }'), json_schema('{"x": 42}', '{ x: number, y: number }');
→ [{"json_schema('{\"x\": \"wrong\"}', '{ x: number }')":false,"json_schema('{\"x\": 42}', '{ x: number, y: number }')":false}]

-- Nested structures - array of objects
SELECT json_schema('[{"x": 1}, {"x": 2}]', '{ x: number }[]'), json_schema('[{"x": 1}, {"x": "wrong"}]', '{ x: number }[]');
→ [{"json_schema('[{\"x\": 1}, {\"x\": 2}]', '{ x: number }[]')":true,"json_schema('[{\"x\": 1}, {\"x\": \"wrong\"}]', '{ x: number }[]')":false}]

-- Nested structures - object with arrays
SELECT json_schema('{"items": [1, 2, 3]}', '{ items: number[] }'), json_schema('{"items": [1, "wrong", 3]}', '{ items: number[] }');
→ [{"json_schema('{\"items\": [1, 2, 3]}', '{ items: number[] }')":true,"json_schema('{\"items\": [1, \"wrong\", 3]}', '{ items: number[] }')":false}]

-- Complex nested structure
SELECT json_schema('{"users": [{"name": "Alice", "age": 30}, {"name": "Bob", "age": 25}]}', '{ users: { name: string, age: number }[] }'), json_schema('{"users": [{"name": "Alice", "age": "thirty"}]}', '{ users: { name: string, age: number }[] }');
→ [{"json_schema('{\"users\": [{\"name\": \"Alice\", \"age\": 30}, {\"name\": \"Bob\", \"age\": 25}]}', '{ users: { name: string, age: number }[] }')":true,"json_schema('{\"users\": [{\"name\": \"Alice\", \"age\": \"thirty\"}]}', '{ users: { name: string, age: number }[] }')":false}]

-- Invalid JSON and schema
SELECT json_schema('{invalid', 'number'), json_schema('42', 'unknown_type');
→ [{"json_schema('{invalid', 'number')":false,"json_schema('42', 'unknown_type')":false}]

-- Empty structures
SELECT json_schema('[]', 'number[]'), json_schema('{}', '{ x: number }'), json_schema('{}', '{}');
→ [{"json_schema('[]', 'number[]')":true,"json_schema('{}', '{ x: number }')":false,"json_schema('{}', '{}')":true}]

-- Use in CHECK constraint
PRAGMA default_vtab_module='memory';
CREATE TABLE events (
  id INTEGER PRIMARY KEY,
  data JSON CHECK (json_schema(data, '{ x: number }[]'))
);
INSERT INTO events VALUES (1, '[{"x": 1}, {"x": 2}]');
SELECT * FROM events;
→ [{"id":1,"data":"[{\"x\":1},{\"x\":2}]"}]
INSERT INTO events VALUES (2, '[{"x": "wrong"}]');
-- error: CHECK constraint failed
SELECT * FROM events;
→ [{"id":1,"data":"[{\"x\":1},{\"x\":2}]"}]
DROP TABLE events;

-- Aggregate JSON Functions (Need table context)
PRAGMA default_vtab_module='memory';
CREATE TABLE json_agg_t (id INT, grp TEXT, val TEXT);
INSERT INTO json_agg_t VALUES (1, 'A', '1'), (2, 'B', 'x'), (3, 'A', '2'), (4, 'B', 'y');
SELECT grp, json_group_array(val) FROM json_agg_t GROUP BY grp ORDER BY grp;
→ [{"grp":"A","json_group_array(val)":"[1,2]"},{"grp":"B","json_group_array(val)":"[\"x\",\"y\"]"}]
SELECT grp, json_group_object(val, id) FROM (SELECT * FROM json_agg_t) GROUP BY grp ORDER BY grp;
→ [{"grp":"A","json_group_object(val, id)":"{\"1\":1,\"2\":3}"},{"grp":"B","json_group_object(val, id)":"{\"x\":2,\"y\":4}"}]
DROP TABLE json_agg_t;
