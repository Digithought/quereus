-- Test declarative schema full lifecycle

-- Step 1: Declare a schema with a table
declare schema main {
	table users {
		id INTEGER PRIMARY KEY,
		name TEXT NOT NULL,
		email TEXT
	}
}

-- run

-- Step 2: Diff against empty database (should show CREATE TABLE as DDL row)
diff schema main;
→ [{"ddl": "create table users (id INTEGER primary key, name TEXT not null, email TEXT)"}]

-- Step 3: Apply the schema (creates the table, returns nothing)
apply schema main;

-- run

-- Step 4: Verify table was created
select count(*) from users;
→ [{"count(*)": 0}]

-- Step 5: Diff again - should now be empty (no rows) since schema matches
diff schema main;
→ []

-- Step 6: Declare schema with seed data
declare schema main {
	table users {
		id INTEGER PRIMARY KEY,
		name TEXT NOT NULL,
		email TEXT
	}

	seed users (
		(1, 'Alice', 'alice@example.com'),
		(2, 'Bob', 'bob@example.com')
	)
}

-- run

-- Step 7: Apply with seed (no rows returned)
apply schema main with seed;

-- run

-- Step 8: Verify seed data was inserted
select * from users order by id;
→ [{"id": 1, "name": "Alice", "email": "alice@example.com"}, {"id": 2, "name": "Bob", "email": "bob@example.com"}]

-- Step 9: Test forward references - declare tables out of order with foreign keys
declare schema main {
	table posts {
		id INTEGER PRIMARY KEY,
		user_id INTEGER NOT NULL,
		title TEXT NOT NULL,
		content TEXT,
		constraint fk_user foreign key (user_id) references users(id)
	}

	table users {
		id INTEGER PRIMARY KEY,
		name TEXT NOT NULL,
		email TEXT
	}

	table comments {
		id INTEGER PRIMARY KEY,
		post_id INTEGER NOT NULL,
		user_id INTEGER NOT NULL,
		text TEXT NOT NULL,
		constraint fk_post foreign key (post_id) references posts(id),
		constraint fk_comment_user foreign key (user_id) references users(id)
	}
}

-- run

-- Step 10: Diff should show posts and comments to create (users already exists)
diff schema main;
→ [{"ddl": "create table posts (id INTEGER primary key, user_id INTEGER not null, title TEXT not null, content TEXT, constraint fk_user foreign key (user_id) references users(id))"}, {"ddl": "create table comments (id INTEGER primary key, post_id INTEGER not null, user_id INTEGER not null, text TEXT not null, constraint fk_post foreign key (post_id) references posts(id), constraint fk_comment_user foreign key (user_id) references users(id))"}]

-- Step 11: Apply the forward-referenced schema
apply schema main;

-- run

-- Step 12: Verify all three tables exist
select count(*) from users;
→ [{"count(*)": 2}]

select count(*) from posts;
→ [{"count(*)": 0}]

select count(*) from comments;
→ [{"count(*)": 0}]

-- Step 13: Insert data respecting foreign key order
insert into posts (id, user_id, title, content) values (1, 1, 'First Post', 'This is the content');
insert into comments (id, post_id, user_id, text) values (1, 1, 2, 'Great post!');

select p.title, c.text, u.name as commenter
from posts p
join comments c on p.id = c.post_id
join users u on c.user_id = u.id;
→ [{"title": "First Post", "text": "Great post!", "commenter": "Bob"}]

-- Step 14: Test table removal via redeclaration (only keep users)
declare schema main {
	table users {
		id INTEGER PRIMARY KEY,
		name TEXT NOT NULL,
		email TEXT
	}
}

-- run

-- Step 15: Diff should show DROP statements for posts and comments
diff schema main;
→ [{"ddl": "DROP TABLE IF EXISTS posts"}, {"ddl": "DROP TABLE IF EXISTS comments"}]

-- Step 16: Apply to drop extra tables
apply schema main;

-- run

-- Step 17: Verify posts and comments are gone
select count(*) from users;
→ [{"count(*)": 2}]

select count(*) from posts;
-- error: Table 'posts' not found in schema path

select count(*) from comments;
-- error: Table 'comments' not found in schema path

-- Step 18: Test composite schema with multiple seeds and forward refs
-- Declare a completely new schema (replacing the previous one)
declare schema main {
	table categories {
		id INTEGER PRIMARY KEY,
		name TEXT NOT NULL
	}

	table products {
		id INTEGER PRIMARY KEY,
		category_id INTEGER NOT NULL,
		name TEXT NOT NULL,
		price REAL NOT NULL,
		constraint fk_category foreign key (category_id) references categories(id)
	}

	seed categories (
		(1, 'Electronics'),
		(2, 'Books'),
		(3, 'Clothing')
	)

	seed products (
		(1, 1, 'Laptop', 999.99),
		(2, 1, 'Mouse', 29.99),
		(3, 2, 'SQL Guide', 49.99)
	)
}

-- run

-- Step 19: Apply complete replacement (drops users, creates categories/products)
apply schema main with seed;

-- run

-- Step 20: Verify relational integrity with join
select p.name as product, c.name as category, p.price
from products p
join categories c on p.category_id = c.id
order by c.id, p.id;
→ [{"product": "Laptop", "category": "Electronics", "price": 999.99}, {"product": "Mouse", "category": "Electronics", "price": 29.99}, {"product": "SQL Guide", "category": "Books", "price": 49.99}]

-- Step 21: Verify old tables are gone
select count(*) from users;
-- error: not found in schema path:

-- Step 22: Test trailing commas in table definitions
declare schema main {
	table config {
		config_key TEXT PRIMARY KEY,
		value TEXT,
		description TEXT,
	}
}

-- run

apply schema main with seed;

-- run

select count(*) from config;
→ [{"count(*)": 0}]

-- Verify products table was dropped
select count(*) from products;
-- error: not found in schema path:

-- Verify categories table was dropped
select count(*) from categories;
-- error: not found in schema path:

-- Step 23: Test explicit main schema qualification
select count(*) from main.config;
→ [{"count(*)": 0}]

-- Step 24: Verify trailing comma test passed
declare schema main {
	table test_trailing {
		a INTEGER PRIMARY KEY,
		b TEXT,
		c TEXT,
	}
}

-- run

apply schema main;

-- run

select count(*) from test_trailing;
→ [{"count(*)": 0}]

-- Step 25: Test custom schema with forward references and CHECK constraints
declare schema Test2 {
	table A {
		Col1 TEXT,
		constraint Col1InB check on insert, update (exists (select 1 from B where new.Col1 = B.Col1))
	}

	table B {
		Col1 TEXT,
		primary key (Col1)
	}

	seed B (
		('valid1'),
		('valid2')
	)
}

-- run

apply schema Test2 with seed;

-- run

-- Verify B has seed data
select * from Test2.B order by Col1;
→ [{"Col1": "valid1"}, {"Col1": "valid2"}]

-- Insert into A with value that exists in B (should succeed)
insert into Test2.A (Col1) values ('valid1');

select * from Test2.A;
→ [{"Col1": "valid1"}]

-- Insert into A with value that doesn't exist in B (should fail)
insert into Test2.A (Col1) values ('invalid');
-- error: CHECK constraint failed

-- Verify schema isolation: Test2 and main are separate
select count(*) from Test2.A;
→ [{"count(*)": 1}]

select count(*) from main.test_trailing;
→ [{"count(*)": 0}]

-- Step 26: Test views in declarative schema
declare schema main {
	table users {
		id INTEGER PRIMARY KEY,
		name TEXT NOT NULL,
		email TEXT,
		active INTEGER DEFAULT 1
	}

	table posts {
		id INTEGER PRIMARY KEY,
		user_id INTEGER NOT NULL,
		title TEXT NOT NULL,
		content TEXT,
		constraint fk_user foreign key (user_id) references users(id)
	}

	view active_users AS select id, name, email from users where active = 1

	view user_posts AS select
		u.name as author,
		p.title,
		p.content
	from users u
	join posts p on u.id = p.user_id
	where u.active = 1

	seed users (
		(1, 'Alice', 'alice@example.com', 1),
		(2, 'Bob', 'bob@example.com', 1),
		(3, 'Charlie', 'charlie@example.com', 0)
	)

	seed posts (
		(1, 1, 'First Post', 'Hello world'),
		(2, 2, 'Second Post', 'Another post'),
		(3, 3, 'Inactive Post', 'This should not appear in view')
	)
}

-- run

-- Step 27: Diff should show tables and views to create
diff schema main;
→ [{"ddl": "DROP TABLE IF EXISTS test_trailing"}, {"ddl": "create table users (id INTEGER primary key, name TEXT not null, email TEXT, active INTEGER default 1)"}, {"ddl": "create table posts (id INTEGER primary key, user_id INTEGER not null, title TEXT not null, content TEXT, constraint fk_user foreign key (user_id) references users(id))"}, {"ddl": "create view active_users as select id, name, email from users where active = 1"}, {"ddl": "create view user_posts as select u.name as author, p.title, p.content from users as u inner join posts as p on u.id = p.user_id where u.active = 1"}]

-- Step 28: Apply schema with views
apply schema main with seed;

-- run

-- Step 29: Test views work correctly
select * from active_users order by id;
→ [{"id": 1, "name": "Alice", "email": "alice@example.com"}, {"id": 2, "name": "Bob", "email": "bob@example.com"}]

select * from user_posts order by author;
→ [{"author": "Alice", "title": "First Post", "content": "Hello world"}, {"author": "Bob", "title": "Second Post", "content": "Another post"}]

-- Step 30: Test view with explicit column names
declare schema main {
	table users {
		id INTEGER PRIMARY KEY,
		name TEXT NOT NULL,
		email TEXT,
		active INTEGER DEFAULT 1
	}

	view user_summary (user_id, full_name, contact) AS select id, name, email from users where active = 1
}

-- run

-- Step 31: Diff should show view changes (drop old views, create new one)
diff schema main;
→ [{"ddl": "DROP TABLE IF EXISTS posts"}, {"ddl": "DROP VIEW IF EXISTS active_users"}, {"ddl": "DROP VIEW IF EXISTS user_posts"}, {"ddl": "create view user_summary (user_id, full_name, contact) as select id, name, email from users where active = 1"}]

-- Step 32: Apply view changes
apply schema main;

-- run

-- Step 33: Test new view with explicit columns
select * from user_summary order by user_id;
→ [{"user_id": 1, "full_name": "Alice", "contact": "alice@example.com"}, {"user_id": 2, "full_name": "Bob", "contact": "bob@example.com"}]

-- Step 34: Test view removal
declare schema main {
	table users {
		id INTEGER PRIMARY KEY,
		name TEXT NOT NULL,
		email TEXT,
		active INTEGER DEFAULT 1
	}
}

-- run

-- Step 35: Diff should show view to drop
diff schema main;
→ [{"ddl": "DROP VIEW IF EXISTS user_summary"}]

-- Step 36: Apply to remove view
apply schema main;

-- run

-- Step 37: Verify view is gone
select count(*) from user_summary;
-- error: not found in schema path:

-- Step 38: Test indexes in declarative schema
-- Note: Using a unique table name to avoid DROP TABLE bug where data persists
declare schema main {
	table products_with_indexes {
		id INTEGER PRIMARY KEY,
		name TEXT NOT NULL,
		category TEXT,
		price REAL
	}

	index idx_products_name on products_with_indexes(name)
	index idx_products_category on products_with_indexes(category, price)
}

-- run

-- Step 39: Diff should show table and indexes to create
diff schema main;
→ [{"ddl": "DROP TABLE IF EXISTS users"}, {"ddl": "create table products_with_indexes (id INTEGER primary key, name TEXT not null, category TEXT, price REAL)"}, {"ddl": "create index idx_products_name on products_with_indexes (name)"}, {"ddl": "create index idx_products_category on products_with_indexes (category, price)"}]

-- Step 40: Apply schema with indexes
apply schema main;

-- run

-- Step 41: Verify table was created
select count(*) from products_with_indexes;
→ [{"count(*)": 0}]

-- Step 42: Insert test data
insert into products_with_indexes values (1, 'Laptop', 'Electronics', 999.99);
insert into products_with_indexes values (2, 'Book', 'Books', 29.99);
insert into products_with_indexes values (3, 'Shirt', 'Clothing', 19.99);

-- Step 43: Verify data
select * from products_with_indexes order by name;
→ [{"id": 2, "name": "Book", "category": "Books", "price": 29.99}, {"id": 1, "name": "Laptop", "category": "Electronics", "price": 999.99}, {"id": 3, "name": "Shirt", "category": "Clothing", "price": 19.99}]

-- Step 44: Diff again - should be empty since schema matches
diff schema main;
→ []

-- Step 45: Test index removal
declare schema main {
	table products_with_indexes {
		id INTEGER PRIMARY KEY,
		name TEXT NOT NULL,
		category TEXT,
		price REAL
	}

	index idx_products_name on products_with_indexes(name)
}

-- run

-- Step 46: Diff should show one index to drop
diff schema main;
→ [{"ddl": "DROP INDEX IF EXISTS idx_products_category"}]

-- Step 47: Apply to remove index
apply schema main;

-- run

-- Step 48: Diff again - should be empty
diff schema main;

-- Test NOT EXISTS in CHECK constraint (regression test for operator spacing)
-- This tests that "NOT EXISTS" is properly stringified with a space between NOT and EXISTS
-- The bug was that "not exists" was being concatenated as "notexists" without a space

declare schema check_not_exists {
	table B (x int);
	table A (
		x int check (not exists(select 1 from B))
	)
}

-- run

-- The key test: DDL should have "not exists" with a space, not "notexists"
diff schema check_not_exists;
→ [{"ddl": "create table check_not_exists.B (x int)"}, {"ddl": "create table check_not_exists.A (x int check (not exists (select 1 from B)))"}]

-- This should apply without parse errors (would fail with "notexists" syntax error)
apply schema check_not_exists;

-- run

-- Step 49: Test schema-level default vtab module
-- When using (default_vtab_module = 'memory') is specified, tables without explicit USING
-- should inherit the schema-level default module
declare schema test_default_module using (default_vtab_module = 'memory') {
	table items {
		id INTEGER PRIMARY KEY,
		name TEXT NOT NULL
	}
}

-- run

-- Diff should show the table with USING memory clause applied
diff schema test_default_module;
→ [{"ddl": "create table test_default_module.items (id INTEGER primary key, name TEXT not null) using memory"}]

-- Apply the schema
apply schema test_default_module;

-- run

-- Verify table works
insert into test_default_module.items values (1, 'Test Item');
select * from test_default_module.items;
→ [{"id": 1, "name": "Test Item"}]

-- Step 50: Test that explicit USING clause takes precedence over schema default
declare schema test_explicit_module using (default_vtab_module = 'memory') {
	table default_table {
		id INTEGER PRIMARY KEY,
		name TEXT
	}

	table explicit_table using memory {
		id INTEGER PRIMARY KEY,
		value TEXT
	}
}

-- run

-- Both tables should use memory module (one from default, one explicit)
diff schema test_explicit_module;
→ [{"ddl": "create table test_explicit_module.default_table (id INTEGER primary key, name TEXT) using memory"}, {"ddl": "create table test_explicit_module.explicit_table (id INTEGER primary key, value TEXT) using memory"}]

apply schema test_explicit_module;

-- run

-- Verify both tables work
insert into test_explicit_module.default_table values (1, 'Default');
insert into test_explicit_module.explicit_table values (1, 'Explicit');
select dt.name, et.value from test_explicit_module.default_table as dt cross join test_explicit_module.explicit_table as et;
→ [{"name": "Default", "value": "Explicit"}]

-- Step 51: Test WITH CONTEXT in declared table
-- This tests that mutation context variables are properly parsed for tables inside declare schema blocks
declare schema test_mutation_context using (default_vtab_module = 'memory') {
	table secure_items (
		id INTEGER PRIMARY KEY,
		value TEXT,
		CONSTRAINT auth_check CHECK (context.allowed = 1)
	) with context (allowed INTEGER)
}

-- run

-- Diff should include the WITH CONTEXT clause
diff schema test_mutation_context;
→ [{"ddl": "create table test_mutation_context.secure_items (id INTEGER primary key, value TEXT, constraint auth_check check (context.allowed = 1)) using memory with context (allowed INTEGER)"}]

-- Apply the schema
apply schema test_mutation_context;

-- run

-- Insert with allowed = 1 should succeed
insert into test_mutation_context.secure_items (id, value)
with context allowed = 1
values (1, 'test value');

select * from test_mutation_context.secure_items;
→ [{"id": 1, "value": "test value"}]

-- Insert with allowed = 0 should fail the CHECK constraint
insert into test_mutation_context.secure_items (id, value)
with context allowed = 0
values (2, 'should fail');
-- error: CHECK constraint failed

-- Verify only the first row exists
select count(*) from test_mutation_context.secure_items;
→ [{"count(*)": 1}]

-- Step 52: Test WITH CONTEXT with default values in declared table
declare schema test_context_defaults using (default_vtab_module = 'memory') {
	table orders (
		id INTEGER PRIMARY KEY,
		amount INTEGER DEFAULT base_amount + tax
	) with context (base_amount INTEGER, tax INTEGER)
}

-- run

apply schema test_context_defaults;

-- run

-- Insert using context for defaults
insert into test_context_defaults.orders (id)
with context base_amount = 100, tax = 15
values (1);

select * from test_context_defaults.orders;
→ [{"id": 1, "amount": 115}]

