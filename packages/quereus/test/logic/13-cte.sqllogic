-- cte.sqllogic - Testing Common Table Expressions (WITH clause)

-- Simple non-recursive CTE
CREATE TABLE base_t (id INTEGER PRIMARY KEY, name TEXT);
INSERT INTO base_t VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');

WITH name_cte AS (
  SELECT name FROM base_t WHERE id > 1
)
SELECT * FROM name_cte ORDER BY name;
→ [{"name":"Bob"},{"name":"Charlie"}]

-- Multiple CTEs
WITH
  cte1 AS (SELECT id, name FROM base_t WHERE id = 1),
  cte2 AS (SELECT id, name FROM base_t WHERE id = 2)
SELECT * FROM cte1 UNION ALL SELECT * FROM cte2 ORDER BY id;
→ [{"id":1,"name":"Alice"},{"id":2,"name":"Bob"}]

-- CTE used in INSERT
CREATE TABLE target_t (id INTEGER, name_upper TEXT);
WITH source_cte AS (
  SELECT id, upper(name) as upper_name FROM base_t WHERE id = 3
)
INSERT INTO target_t (id, name_upper) SELECT id, upper_name FROM source_cte;
SELECT * FROM target_t;
→ [{"id":3,"name_upper":"CHARLIE"}]
DROP TABLE target_t;

-- Basic Recursive CTE (Counting)
WITH RECURSIVE counter(n) AS (
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM counter WHERE n < 5
)
SELECT n FROM counter ORDER BY n;
→ [{"n":1},{"n":2},{"n":3},{"n":4},{"n":5}]

-- Recursive CTE with base table (e.g., simple hierarchy/path)
CREATE TABLE hierarchy (id INTEGER PRIMARY KEY, parent_id INTEGER NULL, name TEXT);
INSERT INTO hierarchy VALUES (1, null, 'Root'), (2, 1, 'Child A'), (3, 1, 'Child B'), (4, 2, 'Grandchild A1');

WITH RECURSIVE path_cte(id, name, level) AS (
  SELECT id, name, 0 FROM hierarchy WHERE parent_id IS NULL
  UNION ALL
  SELECT h.id, p.name || ' -> ' || h.name, p.level + 1
  FROM hierarchy h JOIN path_cte p ON h.parent_id = p.id
)
SELECT name, level FROM path_cte ORDER BY level, name;
→ [{"name":"Root","level":0},{"name":"Root -> Child A","level":1},{"name":"Root -> Child B","level":1},{"name":"Root -> Child A -> Grandchild A1","level":2}]

-- Recursive CTE with aliased table in JOIN and qualified SELECT
-- Bug reproduction: "Table 'E' not found in FROM clause for qualified SELECT *"
CREATE TABLE Entity (id INTEGER PRIMARY KEY, component_id INTEGER NULL, type TEXT);
INSERT INTO Entity VALUES (1, null, 'c'), (2, 1, 'c'), (3, 1, 'c'), (4, 2, 'c'), (5, 3, 'x');

-- Test 1: Qualified column reference E.id in recursive part
WITH RECURSIVE descendants(id) AS (
  SELECT 1
  UNION ALL
  SELECT E.id FROM Entity E
  JOIN descendants D ON E.component_id = D.id
  WHERE E.type = 'c'
)
SELECT id FROM descendants ORDER BY id;
→ [{"id":1},{"id":2},{"id":3},{"id":4}]

-- Test 2: SELECT * from recursive CTE with qualified column in recursive part
WITH RECURSIVE descendants(id) AS (
  SELECT 1
  UNION ALL
  SELECT E.id FROM Entity E
  JOIN descendants D ON E.component_id = D.id
  WHERE E.type = 'c'
)
SELECT * FROM descendants ORDER BY id;
→ [{"id":1},{"id":2},{"id":3},{"id":4}]

-- Test 3: E.* in recursive part (qualified SELECT *)
WITH RECURSIVE descendants(id, component_id, type) AS (
  SELECT id, component_id, type FROM Entity WHERE id = 1
  UNION ALL
  SELECT E.* FROM Entity E
  JOIN descendants D ON E.component_id = D.id
  WHERE E.type = 'c'
)
SELECT id FROM descendants ORDER BY id;
→ [{"id":1},{"id":2},{"id":3},{"id":4}]

-- Test 4: D.* (CTE alias) in recursive part
WITH RECURSIVE descendants(id) AS (
  SELECT 1
  UNION ALL
  SELECT E.id FROM Entity E
  JOIN descendants D ON E.component_id = D.id
  WHERE E.type = 'c'
)
SELECT D.* FROM descendants D ORDER BY id;
→ [{"id":1},{"id":2},{"id":3},{"id":4}]

-- Test 5: Internal recursive CTE reference with alias and qualified SELECT *
-- The recursive reference "descendants D" inside the recursive part
WITH RECURSIVE descendants(id, component_id, type) AS (
  SELECT id, component_id, type FROM Entity WHERE id = 1
  UNION ALL
  SELECT E.id, E.component_id, E.type FROM Entity E
  JOIN descendants D ON E.component_id = D.id
  WHERE E.type = 'c'
)
SELECT D.* FROM descendants D ORDER BY id;
→ [{"id":1,"component_id":null,"type":"c"},{"id":2,"component_id":1,"type":"c"},{"id":3,"component_id":1,"type":"c"},{"id":4,"component_id":2,"type":"c"}]

DROP TABLE Entity;

DROP TABLE base_t;
DROP TABLE hierarchy;
