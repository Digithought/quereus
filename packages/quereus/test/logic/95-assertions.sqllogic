-- Testing CREATE ASSERTION and DROP ASSERTION

-- ===================================
-- Basic DDL Round-Trip
-- ===================================

CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);
CREATE ASSERTION always_passes CHECK (1 = 1);
INSERT INTO users VALUES (1, 'Alice');
COMMIT;
DROP ASSERTION always_passes;
INSERT INTO users VALUES (2, 'Bob');
COMMIT;
SELECT name FROM users ORDER BY id;
→ [{ "name": "Alice" }, { "name": "Bob" }]

DROP TABLE users;
-- run

-- ===================================
-- Assertion Violation at COMMIT
-- ===================================

CREATE TABLE numbers (value INTEGER PRIMARY KEY);
CREATE ASSERTION always_fails CHECK (1 = 0);
-- run

-- Try to commit with the failing assertion
BEGIN;
INSERT INTO numbers VALUES (5);
COMMIT;
-- error: Integrity assertion failed: always_fails

-- Verify nothing was committed
SELECT COUNT(*) FROM numbers;
→ [{ "count(*)": 0 }]

-- Drop the failing assertion
DROP ASSERTION always_fails;
-- run

-- Now we can insert data
INSERT INTO numbers VALUES (5);
COMMIT;
SELECT value FROM numbers;
→ [{ "value": 5 }]

DROP TABLE numbers;
-- run

-- ===================================
-- Single-Table CHECK-like Assertion
-- ===================================

CREATE TABLE accounts (id INTEGER PRIMARY KEY, balance INTEGER);
INSERT INTO accounts VALUES (1, 100);
-- run

-- Balance must be non-negative
CREATE ASSERTION positive_balance CHECK (NOT EXISTS (SELECT 1 FROM accounts WHERE balance < 0));
-- run

-- Valid update: stays positive
BEGIN;
UPDATE accounts SET balance = 50 WHERE id = 1;
COMMIT;
-- run

SELECT balance FROM accounts WHERE id = 1;
→ [{ "balance": 50 }]

-- Invalid update: goes negative → commit fails
BEGIN;
UPDATE accounts SET balance = -10 WHERE id = 1;
COMMIT;
-- error: Integrity assertion failed: positive_balance

-- Verify state is unchanged (rolled back)
SELECT balance FROM accounts WHERE id = 1;
→ [{ "balance": 50 }]

DROP ASSERTION positive_balance;
DROP TABLE accounts;
-- run

-- ===================================
-- Multi-Table Co-Existence (FK-like)
-- ===================================

CREATE TABLE parents (id INTEGER PRIMARY KEY, name TEXT);
CREATE TABLE children (id INTEGER PRIMARY KEY, parent_id INTEGER);
INSERT INTO parents VALUES (1, 'Parent1');
INSERT INTO parents VALUES (2, 'Parent2');
-- run

-- Every child must reference an existing parent
CREATE ASSERTION fk_children CHECK (NOT EXISTS (
  SELECT 1 FROM children c WHERE NOT EXISTS (
    SELECT 1 FROM parents p WHERE p.id = c.parent_id
  )
));
-- run

-- Valid insert: parent exists
BEGIN;
INSERT INTO children VALUES (10, 1);
COMMIT;
-- run

SELECT id FROM children;
→ [{ "id": 10 }]

-- Invalid insert: parent doesn't exist → commit fails
BEGIN;
INSERT INTO children VALUES (20, 999);
COMMIT;
-- error: Integrity assertion failed: fk_children

-- Verify nothing was committed
SELECT COUNT(*) FROM children WHERE id = 20;
→ [{ "count(*)": 0 }]

DROP ASSERTION fk_children;
DROP TABLE children;
DROP TABLE parents;
-- run

-- ===================================
-- Aggregate-Based Global Assertion
-- ===================================

CREATE TABLE items (id INTEGER PRIMARY KEY, name TEXT);
CREATE ASSERTION max_items CHECK ((SELECT COUNT(*) FROM items) <= 3);
-- run

INSERT INTO items VALUES (1, 'a');
INSERT INTO items VALUES (2, 'b');
INSERT INTO items VALUES (3, 'c');
SELECT COUNT(*) FROM items;
→ [{ "count(*)": 3 }]

-- Fourth insert should fail at commit
BEGIN;
INSERT INTO items VALUES (4, 'd');
COMMIT;
-- error: Integrity assertion failed: max_items

-- Verify only 3 items
SELECT COUNT(*) FROM items;
→ [{ "count(*)": 3 }]

DROP ASSERTION max_items;
DROP TABLE items;
-- run

-- ===================================
-- Rollback Clears Violations
-- ===================================

CREATE TABLE vals (id INTEGER PRIMARY KEY, v INTEGER);
CREATE ASSERTION vals_positive CHECK (NOT EXISTS (SELECT 1 FROM vals WHERE v < 0));
-- run

-- Insert negative value, then rollback before commit
BEGIN;
INSERT INTO vals VALUES (1, -5);
ROLLBACK;
-- run

-- Data should be clean
SELECT COUNT(*) FROM vals;
→ [{ "count(*)": 0 }]

-- Valid insert works fine
INSERT INTO vals VALUES (1, 10);
COMMIT;
SELECT v FROM vals WHERE id = 1;
→ [{ "v": 10 }]

DROP ASSERTION vals_positive;
DROP TABLE vals;
-- run

-- ===================================
-- Savepoint Interaction
-- ===================================

CREATE TABLE sp_data (id INTEGER PRIMARY KEY, val INTEGER);
CREATE ASSERTION sp_positive CHECK (NOT EXISTS (SELECT 1 FROM sp_data WHERE val < 0));
-- run

-- Insert valid data, then invalid inside savepoint, rollback savepoint, then commit
BEGIN;
INSERT INTO sp_data VALUES (1, 10);
SAVEPOINT sp1;
INSERT INTO sp_data VALUES (2, -5);
ROLLBACK TO SAVEPOINT sp1;
COMMIT;
-- run

SELECT val FROM sp_data;
→ [{ "val": 10 }]

DROP ASSERTION sp_positive;
DROP TABLE sp_data;
-- run

-- ===================================
-- DROP ASSERTION IF EXISTS
-- ===================================

-- Dropping non-existent assertion without IF EXISTS → error
DROP ASSERTION nonexistent;
-- error: Assertion nonexistent not found

-- Dropping non-existent assertion with IF EXISTS → no error
DROP ASSERTION IF EXISTS nonexistent;
-- run

-- ===================================
-- Duplicate CREATE ASSERTION → Error
-- ===================================

CREATE TABLE dummy (id INTEGER PRIMARY KEY);
-- run

CREATE ASSERTION dup_test CHECK (1 = 1);
-- run

CREATE ASSERTION dup_test CHECK (1 = 1);
-- error: Assertion dup_test already exists

DROP ASSERTION dup_test;
DROP TABLE dummy;
-- run

-- ===================================
-- Autocommit Mode: Assertion Enforced
-- ===================================

CREATE TABLE auto_data (id INTEGER PRIMARY KEY, val INTEGER);
CREATE ASSERTION auto_positive CHECK (NOT EXISTS (SELECT 1 FROM auto_data WHERE val < 0));
-- run

-- In autocommit mode, each DML is implicitly committed.
-- This should fail because assertion is checked at implicit commit.
INSERT INTO auto_data VALUES (1, -10);
-- error: Integrity assertion failed: auto_positive

-- Verify nothing was inserted
SELECT COUNT(*) FROM auto_data;
→ [{ "count(*)": 0 }]

-- Valid insert should work
INSERT INTO auto_data VALUES (1, 10);
SELECT val FROM auto_data WHERE id = 1;
→ [{ "val": 10 }]

DROP ASSERTION auto_positive;
DROP TABLE auto_data;
-- run

-- ===================================
-- Assertion Not Impacted by Unrelated Table
-- ===================================

CREATE TABLE watched (id INTEGER PRIMARY KEY, val INTEGER);
CREATE TABLE unrelated (id INTEGER PRIMARY KEY, val INTEGER);
CREATE ASSERTION watched_check CHECK (NOT EXISTS (SELECT 1 FROM watched WHERE val < 0));
-- run

-- Insert into unrelated table should not trigger watched_check
INSERT INTO unrelated VALUES (1, -100);
COMMIT;
SELECT val FROM unrelated WHERE id = 1;
→ [{ "val": -100 }]

DROP ASSERTION watched_check;
DROP TABLE unrelated;
DROP TABLE watched;
-- run

-- ===================================
-- Explain Assertion Diagnostics
-- ===================================

CREATE TABLE t1 (id INTEGER PRIMARY KEY, u TEXT UNIQUE);
CREATE TABLE t2 (id INTEGER PRIMARY KEY, t1_id INTEGER, FOREIGN KEY (t1_id) REFERENCES t1(id));
-- run

-- Global-style assertion (aggregate): should classify t2 as global
CREATE ASSERTION a_global CHECK ((SELECT COUNT(*) FROM t2) = (SELECT COUNT(*) FROM t2));
-- run

SELECT EXISTS(SELECT 1 FROM explain_assertion('a_global') WHERE classification = 'global') AS ok;
→ [{ "ok": true }]

DROP ASSERTION a_global;
-- run

-- Row-specific-style assertion: equality on PK reduces to row-specific and exposes pk params
CREATE ASSERTION a_row CHECK (EXISTS (SELECT 1 FROM t1 WHERE id = 1));
-- run

SELECT COALESCE(prepared_pk_params, '[]') AS prepared_pk_params FROM explain_assertion('a_row') WHERE classification = 'row' LIMIT 1;
→ [{ "prepared_pk_params": "[\"pk0\"]" }]

DROP ASSERTION a_row;
DROP TABLE t2;
DROP TABLE t1;
-- run

-- ===================================
-- Multiple Assertions
-- ===================================

CREATE TABLE multi (id INTEGER PRIMARY KEY, a INTEGER, b INTEGER);
CREATE ASSERTION multi_a_pos CHECK (NOT EXISTS (SELECT 1 FROM multi WHERE a < 0));
CREATE ASSERTION multi_b_pos CHECK (NOT EXISTS (SELECT 1 FROM multi WHERE b < 0));
-- run

-- Both valid
INSERT INTO multi VALUES (1, 10, 20);
COMMIT;
SELECT COUNT(*) FROM multi;
→ [{ "count(*)": 1 }]

-- a valid, b invalid → fails multi_b_pos
BEGIN;
INSERT INTO multi VALUES (2, 5, -1);
COMMIT;
-- error: Integrity assertion failed: multi_b_pos

-- a invalid, b valid → fails multi_a_pos
BEGIN;
INSERT INTO multi VALUES (3, -1, 5);
COMMIT;
-- error: Integrity assertion failed: multi_a_pos

-- Verify only first row exists
SELECT COUNT(*) FROM multi;
→ [{ "count(*)": 1 }]

DROP ASSERTION multi_a_pos;
DROP ASSERTION multi_b_pos;
DROP TABLE multi;
-- run
