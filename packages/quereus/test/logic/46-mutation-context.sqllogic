-- Mutation Context Tests
-- Tests for table-level mutation context variables used in defaults and constraints
-- Primary use case: application-specific security, rights, signatures, and audit

-- Test 1: Use mutation context in default values
CREATE TABLE products (
	id INTEGER PRIMARY KEY,
	base_price INTEGER,
	final_price INTEGER DEFAULT base_price + markup
) USING memory
WITH CONTEXT (
	markup INTEGER
);

INSERT INTO products (id, base_price)
WITH CONTEXT markup = 50
VALUES (1, 100);

SELECT id, base_price, final_price FROM products
→ [{"id":1,"base_price":100,"final_price":150}]

-- Test 2: Use mutation context in CHECK constraints
CREATE TABLE stock (
	sku TEXT PRIMARY KEY,
	quantity INTEGER,
	CONSTRAINT qty_check CHECK (NEW.quantity >= min_qty)
) USING memory
WITH CONTEXT (
	min_qty INTEGER
);

-- Should succeed with quantity >= min_qty
INSERT INTO stock (sku, quantity)
WITH CONTEXT min_qty = 10
VALUES ('SKU001', 20);

SELECT sku, quantity FROM stock
→ [{"sku":"SKU001","quantity":20}]

-- Should fail with quantity < min_qty
INSERT INTO stock (sku, quantity)
WITH CONTEXT min_qty = 50
VALUES ('SKU002', 30);
-- error: CHECK constraint failed

-- Test 3: Qualified context.varName references
CREATE TABLE items (
	id INTEGER PRIMARY KEY,
	value INTEGER,
	CONSTRAINT value_check CHECK (NEW.value >= context.threshold)
) USING memory
WITH CONTEXT (
	threshold INTEGER
);

INSERT INTO items (id, value)
WITH CONTEXT threshold = 100
VALUES (1, 150);

SELECT id, value FROM items
→ [{"id":1,"value":150}]

-- Test 4: UPDATE with mutation context
CREATE TABLE prices (
	product_id INTEGER PRIMARY KEY,
	price INTEGER,
	CONSTRAINT price_check CHECK (NEW.price >= min_price)
) USING memory
WITH CONTEXT (
	min_price INTEGER
);

INSERT INTO prices
WITH CONTEXT min_price = 0
VALUES (1, 100);

UPDATE prices
WITH CONTEXT min_price = 50
SET price = 75
WHERE product_id = 1;

SELECT price FROM prices WHERE product_id = 1
→ [{"price":75}]

-- Update with invalid context should fail
UPDATE prices
WITH CONTEXT min_price = 100
SET price = 80
WHERE product_id = 1;
-- error: CHECK constraint failed

-- Test 5: DELETE with mutation context
CREATE TABLE audit (
	sku TEXT PRIMARY KEY,
	quantity INTEGER,
	CONSTRAINT delete_check CHECK ON DELETE (allow_delete = 1)
) USING memory
WITH CONTEXT (
	allow_delete INTEGER
);

INSERT INTO audit
WITH CONTEXT allow_delete = 1
VALUES ('A', 10), ('B', 20);

DELETE FROM audit
WITH CONTEXT allow_delete = 1
WHERE sku = 'A';

SELECT sku FROM audit
→ [{"sku":"B"}]

-- Delete with allow_delete = 0 should fail
DELETE FROM audit
WITH CONTEXT allow_delete = 0
WHERE sku = 'B';
-- error: CHECK constraint failed

-- Test 6: Multiple context variables
CREATE TABLE orders (
	id INTEGER PRIMARY KEY,
	amount INTEGER DEFAULT base + tax + shipping
) USING memory
WITH CONTEXT (
	base INTEGER,
	tax INTEGER,
	shipping INTEGER
);

INSERT INTO orders (id)
WITH CONTEXT base = 100, tax = 15, shipping = 5
VALUES (1);

SELECT amount FROM orders WHERE id = 1
→ [{"amount":120}]

-- Test 7: NULL context variables
CREATE TABLE config (
	id INTEGER PRIMARY KEY,
	max_val INTEGER DEFAULT coalesce(limit_val, 999)
) USING memory
WITH CONTEXT (
	limit_val INTEGER NULL
);

INSERT INTO config (id)
WITH CONTEXT limit_val = NULL
VALUES (1);

SELECT max_val FROM config WHERE id = 1
→ [{"max_val":999}]

-- Test 8: RETURNING with mutation context
CREATE TABLE computed (
	id INTEGER PRIMARY KEY,
	result INTEGER DEFAULT base * multiplier
) USING memory
WITH CONTEXT (
	base INTEGER,
	multiplier INTEGER
);

INSERT INTO computed (id)
WITH CONTEXT base = 10, multiplier = 5
VALUES (1)
RETURNING id, result
→ [{"id":1,"result":50}]

-- Test 9: Context variable shadowing column names
CREATE TABLE shadowing (
	id INTEGER PRIMARY KEY,
	value TEXT NULL,
	label TEXT DEFAULT value
) USING memory
WITH CONTEXT (
	value TEXT
);

INSERT INTO shadowing (id)
WITH CONTEXT value = 'from_context'
VALUES (1);

SELECT label FROM shadowing WHERE id = 1
→ [{"label":"from_context"}]

-- Test 10: Deferred constraints with mutation context
CREATE TABLE deferred_test (
	id INTEGER PRIMARY KEY,
	stock INTEGER,
	CONSTRAINT stock_check CHECK (
		NEW.stock >= min_stock OR
		EXISTS (SELECT 1 FROM deferred_test WHERE id = NEW.id AND stock > 0)
	)
) USING memory
WITH CONTEXT (
	min_stock INTEGER
);

BEGIN;

INSERT INTO deferred_test (id, stock)
WITH CONTEXT min_stock = 10
VALUES (1, 15);

COMMIT;

SELECT stock FROM deferred_test WHERE id = 1
→ [{"stock":15}]

