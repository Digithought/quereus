import { expect } from 'aegir/chai';
import * as fc from 'fast-check';
import { Database } from '../src/core/database.js'; // Adjust path as needed
import { compareSqlValues } from '../src/util/comparison.js'; // Import compare helper
import { safeJsonStringify } from '../src/util/serialization.js';

describe('Property-Based Tests', () => {
	let db: Database;

	beforeEach(() => {
		db = new Database();
		// Ensure collations are registered (already done in Database constructor)
	});

	afterEach(async () => {
		await db.close();
	});

	// --- 1. Collation Comparator ---
	describe('Collation Comparator', () => {
		const collationsToTest = ['BINARY', 'NOCASE', 'RTRIM'];

		for (const collationName of collationsToTest) {
			it(`should sort consistently with compare function for ${collationName} collation`, async () => {
				await db.exec(`CREATE TABLE coll_t (id INTEGER PRIMARY KEY, txt TEXT COLLATE ${collationName}) USING memory`);

				await fc.assert(fc.asyncProperty(fc.array(fc.string(), { minLength: 1, maxLength: 20 }), async (strings) => {
					// Use a Map to handle potential duplicate strings generated by fast-check, preserving insertion order for comparison
					const uniqueStringsMap = new Map<string, boolean>();
					strings.forEach(s => uniqueStringsMap.set(s, true));
					const uniqueStrings = Array.from(uniqueStringsMap.keys());

					// Reset table for each property run
					await db.exec('DELETE FROM coll_t');
					const stmt = await db.prepare('INSERT INTO coll_t (txt) VALUES (?)');
					try {
						for (const str of uniqueStrings) {
							await stmt.run([str]);
						}
					} finally {
						await stmt.finalize();
					}

					// Get sorted results from the database
					const dbSorted: Record<string, any>[] = [];
					for await (const row of db.eval(`SELECT txt FROM coll_t ORDER BY txt`)) {
						dbSorted.push(row);
					}
					const dbSortedStrings = dbSorted.map((row: Record<string, any>) => row.txt as string);

					// Sort the original unique strings using the JavaScript compare function
					const jsSortedStrings = [...uniqueStrings].sort((a, b) => compareSqlValues(a, b, collationName));

					// Compare the two sorted lists
					expect(dbSortedStrings).to.deep.equal(jsSortedStrings, `Mismatch for collation ${collationName} with input: ${safeJsonStringify(uniqueStrings)}`);
				}), { numRuns: 50 }); // Keep numRuns reasonable for CI
			});
		}
	});

	// --- 2. Numeric Affinity ---
	describe('Numeric Affinity', () => {
		// Define an arbitrary that generates values representable as NULL, INTEGER, REAL, or TEXT that might look numeric
		const sqlValueArbitrary = fc.oneof(
			fc.constant(null),
			fc.integer(),
			fc.float({ noNaN: true }), // Exclude NaN as it complicates SQL comparisons
			fc.boolean(),
			fc.string(), // Includes numeric-looking strings
			fc.bigInt()
			// fc.uint8Array() // Skip BLOBs for numeric affinity tests
		);

		it('should compare values according to numeric affinity', async () => {
			await db.exec('CREATE TABLE num_t (id INTEGER PRIMARY KEY, v ANY) USING memory'); // Use ANY type

			await fc.assert(fc.asyncProperty(sqlValueArbitrary, sqlValueArbitrary, async (valA, valB) => {
				// Use compareSqlValues as the JS source of truth for how values *should* compare
				const expectedComparison = compareSqlValues(valA, valB, 'BINARY'); // Use BINARY as base for comparison logic

				// Query the database to see how it compares the values
				let dbComparison: number;
				try {
					// Check A = B using eval and taking the first row
					let eqResult: Record<string, any> | undefined;
					for await (const row of db.eval('SELECT ? = ? as result', [valA, valB])) {
						eqResult = row;
						break; // Only need the first (and only) row
					}
					if (eqResult?.result) {
						dbComparison = 0;
					} else {
						// Check A < B using eval and taking the first row
						let ltResult: Record<string, any> | undefined;
						for await (const row of db.eval('SELECT ? < ? as result', [valA, valB])) {
							ltResult = row;
							break; // Only need the first row
						}
						dbComparison = ltResult?.result ? -1 : 1;
					}
				} catch (e: any) {
					// If the comparison itself throws an error in SQL, fail the property test
					fc.pre(false); // Discard this run if SQL comparison fails
					throw new Error(`SQL comparison failed for (${valA}, ${valB}): ${e.message}`);
				}

				expect(dbComparison).to.equal(expectedComparison,
					`Mismatch for compare(${safeJsonStringify(valA)}, ${safeJsonStringify(valB)}). JS=${expectedComparison}, DB=${dbComparison}`
				);
			}), { numRuns: 200 }); // Increase runs for more diverse value pairs
		});

		// TODO: Add tests for aggregation functions with mixed types (e.g., SUM('1', 2))
	});

	// --- 3. JSON Roundtrip ---
	describe('JSON Roundtrip', () => {
		const jsonValueArbitrary = fc.jsonValue(); // Generates JSON-compatible values: null, boolean, number, string, array, object

		it('should preserve JSON values through json() and json_extract()', async () => {
			await fc.assert(fc.asyncProperty(jsonValueArbitrary, async (originalValue) => {
				let retrievedValueJson: string | null = null;
				let retrievedValueParsed: any;

				try {
					// Insert the value as JSON text using json() or just pass it directly if json() isn't strictly needed for insertion
					// We'll query using json_extract which expects the first arg to be JSON text
					// Use json_quote to ensure the value is stored as valid JSON text
					// Use double quotes for JS string to allow single quotes for SQL path '$'
					// Cast originalValue to any for the binding, as json_quote handles objects/arrays
					const queryResult = await db.eval("SELECT json_extract(json_quote(?), '$') as result", [originalValue as any]).next();
					if (!queryResult.done && queryResult.value) {
						// json_extract returns the *value* itself, not necessarily JSON text
						retrievedValueParsed = queryResult.value.result;
					} else {
						throw new Error('json_extract query returned no result.');
					}

				} catch (e: any) {
					// If the query itself fails, discard the run
					fc.pre(false);
					throw new Error(`JSON roundtrip query failed for value ${safeJsonStringify(originalValue)}: ${e.message}`);
				}

				// Need deep comparison for objects and arrays
				expect(retrievedValueParsed).to.deep.equal(originalValue,
					`JSON roundtrip mismatch.\nOriginal: ${safeJsonStringify(originalValue)}\nRetrieved: ${safeJsonStringify(retrievedValueParsed)}`
				);
			}), { numRuns: 200 });
		});
	});

});
