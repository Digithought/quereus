# Query Optimizer Design and Roadmap

## Overview

The query optimizer in SQLiter is responsible for choosing an efficient execution plan for SQL queries, particularly focusing on join order selection and leveraging virtual table capabilities. The core logic resides in the `src/compiler/planner/` directory, primarily within the `QueryPlannerContext` class and related helpers.

Its main responsibilities are:

1.  **Base Relation Planning:** Analyzing potential access paths for each individual base table (or subquery/function source) using the `xBestIndex` method of the corresponding virtual table module. This determines the cost and estimated rows for scanning the table under given constraints.
2.  **Join Candidate Identification:** Extracting potential join operations (INNER, LEFT, CROSS, etc.) and their conditions from the query's `FROM` clause.
3.  **Cost-Based Join Order Selection:** Employing a greedy algorithm (`planExecution` method in `QueryPlannerContext`) to iteratively select the most cost-effective join to perform next. Currently, it uses a Nested Loop Join (NLJ) cost model:
    *   It estimates the cost of executing a join with either relation as the outer loop.
    *   The cost considers the cost of scanning the outer relation plus the cost of scanning the inner relation for each row of the outer relation (`OuterCost + OuterRows * InnerCost`).
    *   Inner loop scanning cost is determined by invoking `planTableAccess` (which calls `xBestIndex`) considering constraints from the join condition potentially involving columns from the outer relation.
4.  **Execution Plan Generation:** Producing an ordered list of `PlannedStep` objects (`PlannedScanStep`, `PlannedJoinStep`) representing the chosen execution strategy.
5.  **Order By Consumption Tracking:** Analyzing the plan generated by `xBestIndex` for base scans and propagating whether the required `ORDER BY` clause is satisfied by the plan, avoiding unnecessary external sorts. NLJ inherently preserves the order of the *outer* relation stream.

## Current Planner Details (`QueryPlannerContext`)

The planning process for a `SELECT` statement generally follows these steps:

1.  **Initialization:**
    *   The `QueryPlannerContext` is created.
    *   Base relations (tables, subqueries, TVFs) mentioned in the `FROM` clause are identified.
    *   For each base relation, `planTableAccess` is called to determine the optimal scan plan using the virtual table's `xBestIndex`. This provides initial cost and row estimates. These become initial `PlannedScanStep`s.
2.  **Join Candidate Extraction:** The planner analyzes the `FROM` clause structure (including explicit `JOIN` keywords and comma-separated tables) to create a list of `JoinCandidateInfo` objects, representing potential joins between relations. Basic selectivity estimation is performed.
3.  **Greedy Join Selection Loop:**
    *   The planner iterates as long as there are multiple relations yet to be joined.
    *   In each iteration, it evaluates the cost of all possible joins between the currently available relations using the `_costJoinCandidate` method.
    *   `_costJoinCandidate` estimates the cost for both possible outer-inner loop configurations for an NLJ. It relies on calling `planTableAccess` to determine the cost of accessing the inner table based on the join condition and the outer relation's context.
    *   The join candidate with the lowest estimated NLJ cost is selected.
    *   A `PlannedJoinStep` is created, referencing the previously generated steps for its left and right inputs and specifying which input acts as the outer and inner loop based on the cost analysis.
    *   The newly created `PlannedJoinStep` replaces its input steps in the set of available relations for the next iteration.
4.  **Final Plan:** The loop continues until only one relation (representing the final result of all joins) remains, or no more joins can be performed. The sequence of `PlannedStep` objects created constitutes the execution plan.
5.  **VDBE Generation:** The `compilePlannedStepsLoop` function then takes this `PlannedStep[]` array and generates the corresponding VDBE bytecode, constructing the nested loops and condition checks according to the plan.

## Order By Optimization

The planner integrates with the `ORDER BY` clause:

*   When planning base table access (`planTableAccessHelper` calling `xBestIndex`), it checks if the VTab reports that the chosen access path already satisfies the query's `ORDER BY` clause (`orderByConsumed`).
*   This boolean result is stored in the `PlannedScanStep`.
*   The `compileSelectStatement` function checks the final `PlannedStep`. If it's a `PlannedScanStep`, it uses the `orderByConsumed` flag directly. If it's a `PlannedJoinStep`, it currently assumes NLJ preserves the outer loop's order and checks the order consumption of the step that produced the final outer relation.
*   If the order is consumed by the plan, the final external `Opcode.Sort` is skipped.

## Limitations

*   **Cost Model:** The current cost model is simple and only considers NLJ. It doesn't account for other potential join algorithms (Hash Join, Merge Join) which might be more efficient in certain scenarios. CPU costs vs. I/O costs are not explicitly modeled.
*   **Selectivity Estimation:** Join selectivity estimation is currently very basic (defaults or simple heuristics) and doesn't deeply analyze predicate specifics.
*   **Statistics:** The planner relies heavily on `estimatedRows` and `estimatedCost` returned by `xBestIndex`. The accuracy of these statistics is crucial. Currently, there's no built-in mechanism like `ANALYZE` to gather accurate statistics for base tables; modules might provide estimates, or defaults are used.
*   **Complex Predicates:** Handling of complex `WHERE` or `JOIN ON` conditions involving functions or OR clauses during costing and `xBestIndex` interaction could be improved. Predicate pushdown analysis currently checks dependencies within `AND` clauses but doesn't handle partial pushdown or `OR` clauses.
*   **Subquery/CTE Planning:** Planning for queries involving complex subqueries or CTEs within the main query block is not deeply integrated into the cost-based join ordering yet.

## Future Work & Potential Enhancements

Given the focus on virtual tables, especially potentially distributed ones, optimizations that reduce data transfer and computation at the source are likely to yield the most significant benefits. Key priorities include:

*   **Constant Folding:** Implement thorough constant folding during compilation to simplify expressions evaluated repeatedly.
*   **Advanced Predicate Pushdown:** Enhance the interaction between the planner (`extractConstraints`) and `xBestIndex` to:
    *   Push down more complex predicates involving functions or `OR` clauses where supported by the VTable.
    *   Handle partial predicate pushdown (pushing parts of an `AND` clause even if other parts cannot be handled by the VTable).
    *   Improve analysis of predicates involving multiple tables within join conditions for more effective filtering.
*   **Subquery Optimizations:** Implement techniques like subquery flattening (converting subqueries into joins) and decorrelation (rewriting correlated subqueries to be independent) to avoid redundant computations, particularly important for distributed systems.
*   **Implement Hash Join/Merge Join:** Add costing logic and VDBE code generation for Hash Joins (useful for equi-joins on large datasets) and potentially Merge Joins (if inputs are sorted). While potentially less critical than logical optimizations given effective VTable caching, these offer alternative join strategies.
*   **Improve Cost Model:** Refine cost estimations to better reflect potential CPU vs. I/O costs, especially relevant for complex expressions or functions. Incorporate network latency considerations for distributed VTabs.
*   **Improve Selectivity Estimation:** Use histograms or more sophisticated analysis of predicates to get better estimates for join selectivity and filter effectiveness.
*   **Implement `ANALYZE`:** Add an `ANALYZE` command to gather statistics (row counts, value distributions) for tables (especially the built-in `MemoryTable`) and store them for the planner's use. Allow VTabs to optionally provide richer statistics.
*   **Enhanced Subquery/CTE Integration (Costing):** Integrate the planning of materialized CTEs and subqueries more tightly into the main query's cost-based planning *after* initial optimization techniques are applied.
*   **Pushdown Optimizations (Other):** Explore opportunities to push down projections or partial aggregations where VTabs support them.
*   **Explore Alternative Planners:** Investigate more advanced planning algorithms beyond the simple greedy approach if needed for very complex queries.

## Current Status

A functional, cost-based query planner exists, focusing on Nested Loop Join (NLJ) order selection. It interacts with the virtual table interface (`xBestIndex`) to estimate costs for base table access and inner join loop access. It successfully generates `PlannedStep` arrays that dictate the execution flow, including optimizations for consumed `ORDER BY` clauses to avoid unnecessary sorting.
