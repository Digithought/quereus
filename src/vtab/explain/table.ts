import { VirtualTable } from '../table.js';
import type { QueryPlanModule } from './module.js';
import type { Database } from '../../core/database.js';
import type { QueryPlanStep } from '../../core/explain.js';
import type { TableSchema } from '../../schema/table.js';
import { SqliterError } from '../../common/errors.js';
import { StatusCode, type Row, type SqlValue, type RowIdRow } from '../../common/types.js';
import type { FilterInfo } from '../filter-info.js';

/**
 * Represents an instance of the query_plan virtual table for a specific query.
 */
export class QueryPlanTable extends VirtualTable {
    public readonly tableSchema: TableSchema; // Make public if needed by base or subclasses
    private readonly planSteps: ReadonlyArray<QueryPlanStep>;

    /** @internal Use QueryPlanModule.xConnect */
    constructor(
        db: Database,
        module: QueryPlanModule,
        tableName: string, // Alias provided by user
        schema: TableSchema, // The fixed schema defined in module
        planSteps: ReadonlyArray<QueryPlanStep> // Plan generated by _getPlanInfo
    ) {
        super(db, module as any, schema.schemaName, tableName);
        this.tableSchema = schema; // Assign the fixed schema
        this.planSteps = planSteps;
    }

    getSchema(): TableSchema {
        return this.tableSchema;
    }

    isReadOnly(): boolean {
        return true; // Query plan is read-only
    }

    // Override xBestIndex - not needed as module handles it
    // xBestIndex(...) { ... }

    // Implement required abstract methods
    async xDisconnect(): Promise<void> {
        // No resources to release for this table instance
    }

    async xUpdate(/* values: SqlValue[], rowid: bigint | null */): Promise<{ rowid?: bigint; }> {
        throw new SqliterError("Cannot modify query plan table", StatusCode.READONLY);
    }

    // Other methods like xUpdate, xBegin etc. are not applicable
    // and will likely throw errors if called via base class or VDBE misuse.

    async* xQuery(_filterInfo: FilterInfo): AsyncIterable<RowIdRow> {
        // QueryPlanTable iteration doesn't typically use filterInfo for filtering itself.
        // The planSteps are fixed at table connection time.
        // Column order must match QUERY_PLAN_COLUMNS in module.ts
        for (const currentStep of this.planSteps) {
            const rowId = BigInt(currentStep.id); // Assuming id can be safely cast to BigInt for rowid
            const row: SqlValue[] = [
                currentStep.id,
                currentStep.parentId ?? null,
                currentStep.subqueryLevel,
                currentStep.op,
                currentStep.detail ?? null,
                currentStep.objectName ?? null,
                currentStep.alias ?? null,
                currentStep.estimatedCost ?? null,
                (currentStep.estimatedRows === undefined || currentStep.estimatedRows === null) ? null : ((typeof currentStep.estimatedRows === 'bigint' && currentStep.estimatedRows <= BigInt(Number.MAX_SAFE_INTEGER) && currentStep.estimatedRows >= BigInt(Number.MIN_SAFE_INTEGER)) ? Number(currentStep.estimatedRows) : String(currentStep.estimatedRows)), // Convert BigInt to number or string
                currentStep.idxNum ?? null,
                currentStep.idxStr ?? null,
                currentStep.orderByConsumed ? 1 : 0,
                currentStep.constraintsDesc ?? null,
                currentStep.orderByDesc ?? null,
                currentStep.joinType ?? null,
                currentStep.isCorrelated ? 1 : 0
            ];
            yield [rowId, row];
        }
    }
}
