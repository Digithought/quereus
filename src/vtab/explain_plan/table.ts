import { VirtualTable } from '../table.js';
import type { ExplainPlanModule } from './module.js';
import type { Database } from '../../core/database.js';
import type { TableSchema } from '../../schema/table.js';
import { QuereusError } from '../../common/errors.js';
import { StatusCode, type Row, type SqlValue } from '../../common/types.js';
import type { FilterInfo } from '../filter-info.js';
import type { PlanNode } from '../../planner/nodes/plan-node.js';
import { Scheduler } from '../../runtime/scheduler.js';
import { emitPlanNode } from '../../runtime/emitters.js';
import type { RowOp } from '../../parser/ast.js';

/**
 * Represents an instance of the query_plan virtual table for a specific query.
 */
export class ExplainPlanTable extends VirtualTable {
    public readonly tableSchema: TableSchema; // Make public if needed by base or subclasses

    /** @internal Use QueryPlanModule.xConnect */
    constructor(
        db: Database,
        module: ExplainPlanModule,
        tableName: string, // Alias provided by user
        schema: TableSchema, // The fixed schema defined in module
        private readonly plan: PlanNode // Plan generated by _getPlanInfo
    ) {
        super(db, module as any, schema.schemaName, tableName);
        this.tableSchema = schema; // Assign the fixed schema
    }

    getSchema(): TableSchema {
        return this.tableSchema;
    }

    isReadOnly(): boolean {
        return true; // Query plan is read-only
    }

    // Implement required abstract methods
    async xDisconnect(): Promise<void> {
        // No resources to release for this table instance
    }

    async xUpdate(
      _operation: RowOp,
      _values?: Row,
      _oldKeyValues?: Row
    ): Promise<Row | undefined> {
        throw new QuereusError("Cannot modify query plan table", StatusCode.READONLY);
    }

    async* xQuery(_filterInfo: FilterInfo): AsyncIterable<Row> {
			const program = emitPlanNode(this.plan);
			const schedule = new Scheduler(program);
			for (const instruction of schedule.instructions) {
				// TODO: Implement this to yield rows representing plan steps
        // For now, yields nothing, matching the old behavior of yielding no Row.
			}
      // To satisfy AsyncIterable<Row> if loop is empty or TODO not done:
      if (false) yield [] as Row; // Make it type-check, but unreachable
      return;
    }
}
