import type { Compiler } from './compiler.js';
// import type { JoinLevelInfo } from './select.js'; // Keep for reference, remove later
import type * as AST from '../parser/ast.js';
import { Opcode } from '../vdbe/opcodes.js';
import { analyzeSubqueryCorrelation } from './correlation.js';
import { compileUnhandledWhereConditions, verifyPlannedConstraints } from './where-verify.js'; // Import verifyPlannedConstraints
import { createLogger } from '../common/logger.js'; // Import logger
import type { PlannedStep, PlannedScanStep, PlannedJoinStep, QueryRelation } from './planner/types.js';
import { getStepPrimaryAlias } from './planner/helpers.js';
import { SqliteError } from '../common/errors.js';
import { StatusCode } from '../common/types.js';
import type { ColumnResultInfo } from './structs.js'; // Corrected import path
// import type { TableSchema } from '../schema/table.js'; // Not directly used in this merged file

const log = createLogger('compiler:select-loop'); // Create logger instance
const warnLog = log.extend('warn');
const errorLog = log.extend('error');

/**
 * Context information passed to the row processing callback
 */
export interface RowProcessingContext {
	// Original WHERE check jump target (if applicable)
	whereFailTarget?: number;
	// LEFT JOIN padding information (set when processing padding)
	isLeftJoinPadding?: {
		innerRelation: QueryRelation;
		innerContributingCursors: ReadonlySet<number>;
	};
	// Information needed for NULL padding and column mapping
	finalColumnMap: ReadonlyArray<ColumnResultInfo>;
}

/**
 * Function signature for processing a row within the innermost loop
 */
export type ProcessRowCallback = (
	compiler: Compiler,
	stmt: AST.SelectStmt | null, // Original statement or null during recursion
	plannedStepsContext: PlannedStep[],
	activeOuterCursors: ReadonlySet<number>,
	context: RowProcessingContext
) => number; // Returns the address of the start of the processing logic

/** Information needed to close a loop generated by generateVdbeForStep */
interface VdbeLoopInfo {
	loopStartAddr: number; // Resolved address of VFilter/loop start
	eofAddr: number;       // Resolved placeholder ID for EOF jump target
	vNextAddr: number;     // Address of the VNext instruction for this loop
	vNextCursor: number;   // Cursor ID used by VNext
	// Optional fields for specific step types
	joinFailAddr?: number; // Resolved placeholder ID for Join condition failure (jumps *after* VNext)
	matchReg?: number;     // Register for LEFT JOIN matching
	callbackAddr?: number; // Address of the start of the row processing logic (needed for padding jump)
	innermostVNextAddr: number; // Address of the VNext for the *innermost* loop of this branch (MUST be set)
	innermostWhereFailTarget?: number; // Propagated placeholder for WHERE failure target
	verifyFailAddr?: number; // Placeholder for verification failure target
}

/** Context passed down through recursive VDBE generation */
interface LoopGenerationContext {
	innermostLoopEndAddrPlaceholder: number; // Target for end of all loops
	whereExpr: AST.Expression | undefined; // The original WHERE clause
	whereFailTargetPlaceholder: number | undefined; // Target if WHERE fails
	allFromCursors: ReadonlySet<number>; // All cursors in the original FROM
	finalColumnMap: ReadonlyArray<ColumnResultInfo>; // Map of final result columns to help with padding
	coreColumnMap: ReadonlyArray<ColumnResultInfo>; // Map of raw FROM columns to registers
}

/**
 * Recursively generates VDBE code for a planned execution step.
 * Returns information about the generated loop structure.
 *
 * Key addresses generated/resolved within this function or its children:
 * - step.loopStartAddr: The address of the VFilter/first instruction of this step's loop.
 * - step.eofAddr: Placeholder ID resolved to the address *after* this step's VNext.
 * - step.joinFailAddr (for Join): Placeholder ID resolved *after* the inner loop's VNext.
 *
 * Key addresses returned in VdbeLoopInfo:
 * - loopStartAddr: Same as step.loopStartAddr.
 * - eofAddr: Same as step.eofAddr.
 * - vNextAddr: The actual address of this step's VNext instruction.
 * - vNextCursor: The cursor used by this step's VNext.
 * - joinFailAddr: Same as step.joinFailAddr.
 * - matchReg: Register for LEFT JOIN match flag.
 * - callbackAddr: Address of the start of the row processing logic (needed for padding jump).
 * - innermostVNextAddr: Address of the VNext of the actual innermost loop generated by this branch.
 */
function generateVdbeForStep(
	compiler: Compiler,
	step: PlannedStep,
	plannedSteps: PlannedStep[],
	stepIndex: number,
	activeOuterCursors: ReadonlySet<number>,
	processRowCallback: ProcessRowCallback,
	loopContext: LoopGenerationContext
): VdbeLoopInfo {
	log(`Generating VDBE for step ${stepIndex}: ${step.type} (Alias: ${getStepPrimaryAlias(step)}, OuterCursors: {${[...activeOuterCursors].join(',')}})`);
	const isInnermostStep = (stepIndex === plannedSteps.length - 1);

	if (step.type === 'Scan') {
		const scanStep = step as PlannedScanStep;
		// --- Generate VDBE for SCAN --- //
		const addrAfterVFilterPlaceholder = compiler.allocateAddress(`scanAfterVFilter_${scanStep.relation.alias}`);
		const eofPlaceholder = compiler.allocateAddress(`scanEof_${scanStep.relation.alias}`);
		scanStep.eofAddr = eofPlaceholder;
		const cursor = [...scanStep.relation.contributingCursors][0];
		const plan = scanStep.plan;

		// Compile VFilter arguments
		let regArgsStart = 0;
		let filterP4: any = { idxNum: 0, idxStr: null, nArgs: 0 };
		if (plan.idxNum !== 0) {
			const argsToCompile: { constraintIdx: number, expr: AST.Expression }[] = [];
			plan.usage.forEach((usage: { argvIndex: number; omit: boolean }, constraintIdx: number) => {
				if (usage.argvIndex > 0) {
					const expr = plan.constraintExpressions?.get(constraintIdx);
					if (!expr) throw new SqliteError(`Internal error: Missing expression for constraint ${constraintIdx} in Scan step`, StatusCode.INTERNAL);
					while (argsToCompile.length < usage.argvIndex) { argsToCompile.push(null as any); }
					argsToCompile[usage.argvIndex - 1] = { constraintIdx, expr };
				}
			});
			const finalArgsToCompile = argsToCompile.filter(a => a !== null);
			if (finalArgsToCompile.length > 0) {
				regArgsStart = compiler.allocateMemoryCells(finalArgsToCompile.length);
				log(`    Compiling ${finalArgsToCompile.length} VFilter args for cursor ${cursor} starting at reg ${regArgsStart}`);
				finalArgsToCompile.forEach((argInfo, i) => {
					const correlation = analyzeSubqueryCorrelation(compiler, argInfo.expr, activeOuterCursors);
					compiler.compileExpression(argInfo.expr, regArgsStart + i, correlation);
				});
			}
			filterP4 = {
				idxNum: plan.idxNum,
				idxStr: plan.idxStr,
				nArgs: finalArgsToCompile.length,
				aConstraint: plan.constraints,
				aConstraintUsage: plan.usage,
			};
		}

		// Emit VFilter - Loop starts here
		scanStep.loopStartAddr = compiler.getCurrentAddress(); // Actual address of VFilter
		compiler.emit(Opcode.VFilter, cursor, scanStep.eofAddr, regArgsStart, filterP4, 0, `Filter/Scan Base ${scanStep.relation.alias} (Cursor ${cursor})`);

		// Resolve the address for instructions immediately AFTER VFilter (and its potential checks)
		// This is where VNext should jump to process the next row.
		compiler.resolveAddress(addrAfterVFilterPlaceholder);

		// Verify constraints if needed
		// We call this *after* VFilter successfully positions the cursor on a row
		verifyPlannedConstraints(compiler, plan, scanStep.relation.schema, cursor, scanStep.eofAddr, activeOuterCursors);

		// WHERE Clause Verification (Only if this is the innermost step)
		let callbackAddr = -1;
		if (isInnermostStep) {
			const currentActiveCursors = new Set([...activeOuterCursors, cursor]);
			const whereFailTarget = loopContext.whereFailTargetPlaceholder;
			if (loopContext.whereExpr && whereFailTarget) {
				log(`  Emitting WHERE check at innermost SCAN step ${stepIndex}. Active: {${[...currentActiveCursors].join(',')}}`);
				// Jump target for WHERE failure will be resolved AFTER the VNext of this loop
				compileUnhandledWhereConditions(compiler, loopContext.whereExpr, [...currentActiveCursors], whereFailTarget, scanStep);
			}

			// Invoke Row Processing Callback with proper context
			const processingContext: RowProcessingContext = {
				whereFailTarget: whereFailTarget,
				isLeftJoinPadding: undefined, // Not padding for base scan
				finalColumnMap: loopContext.finalColumnMap
			};
			callbackAddr = processRowCallback(compiler, null, plannedSteps, currentActiveCursors, processingContext);
		} else {
			log(`  Scan step ${stepIndex} is not innermost. Processing will be handled by nested steps or join logic.`);
		}

		// Loop Closing
		const vNextAddr = compiler.getCurrentAddress();
		compiler.emit(Opcode.VNext, cursor, addrAfterVFilterPlaceholder, 0, null, 0, `VNext Cursor ${cursor} -> ${addrAfterVFilterPlaceholder}`);
		// Resolve EOF Jump Target (Address *after* VNext)
		compiler.resolveAddress(scanStep.eofAddr);

		// Resolve WHERE Fail Target if this was the innermost step
		const whereFailTarget = loopContext.whereFailTargetPlaceholder;
		if (isInnermostStep && whereFailTarget) {
			log(`  Resolving WHERE fail target ${whereFailTarget} after innermost VNext (${vNextAddr})`);
			compiler.resolveAddress(whereFailTarget);
		}

		return {
			loopStartAddr: scanStep.loopStartAddr,
			eofAddr: scanStep.eofAddr,
			vNextAddr: vNextAddr,
			vNextCursor: cursor,
			callbackAddr: callbackAddr, // Pass callback address up
			innermostVNextAddr: vNextAddr, // For Scan, this IS the innermost VNext
			innermostWhereFailTarget: whereFailTarget, // Pass placeholder ID up
		};

	} else if (step.type === 'Join') {
		const joinStep = step as PlannedJoinStep;

		// 1. Determine which input is outer/inner based on the plan
		const outerPlannedStep = joinStep.outerStep;
		const innerPlannedStep = joinStep.innerStep;
		const outerAlias = getStepPrimaryAlias(outerPlannedStep);
		const innerAlias = getStepPrimaryAlias(innerPlannedStep);
		const outerStepIndex = plannedSteps.findIndex(s => s === outerPlannedStep);
		const innerStepIndex = plannedSteps.findIndex(s => s === innerPlannedStep);

		if (outerStepIndex === -1 || innerStepIndex === -1) {
			throw new SqliteError(`Internal error: Could not find outer/inner step index for join ${outerAlias}<->${innerAlias}`, StatusCode.INTERNAL);
		}

		log(`  Generating Outer Loop for ${outerAlias} (Step Index: ${outerStepIndex})`);
		// Generate Outer Loop Code Recursively
		const outerLoopInfo = generateVdbeForStep(
			compiler,
			outerPlannedStep,
			plannedSteps,
			outerStepIndex,
			activeOuterCursors, // Pass outer cursors from our caller
			processRowCallback,
			loopContext // Pass context down
		);

		// --- Code Inside Outer Loop --- //
		log(`  Inside Outer Loop of ${outerAlias} (at addr ${compiler.getCurrentAddress()})`);

		// Determine Cursors Active for Inner Loop Processing
		const outerRelation = (outerPlannedStep.type === 'Scan')
			? outerPlannedStep.relation
			: (outerPlannedStep.type === 'Join' ? outerPlannedStep.outputRelation : null);
		if (!outerRelation) throw new SqliteError(`Internal error: Could not determine outer relation for join step`, StatusCode.INTERNAL);
		const innerLoopActiveOuterCursors = new Set([...activeOuterCursors, ...outerRelation.contributingCursors]);

		log(`    Active cursors for inner loop (${innerAlias}): {${[...innerLoopActiveOuterCursors].join(',')}}`);

		// Setup LEFT JOIN match flag (if needed)
		if (joinStep.joinType === 'left') {
			joinStep.matchReg = compiler.allocateMemoryCells(1);
			// Initialize *inside* the outer loop, before starting the inner loop
			compiler.emit(Opcode.Integer, 0, joinStep.matchReg, 0, null, 0, `Init LEFT JOIN Match Flag for ${innerAlias}`);
		}

		// Placeholder for the jump target if the JOIN's ON condition OR inner plan constraint verification fails.
		// This should jump past the inner loop's VNext/padding for the current outer row.
		const joinFailPlaceholder = compiler.allocateAddress(`joinFail_${getStepPrimaryAlias(step)}`);
		joinStep.joinFailAddr = joinFailPlaceholder; // Store placeholder ID

		// Generate Inner Loop Code Recursively
		log(`  Generating Inner Loop for ${innerAlias} (Step Index: ${innerStepIndex})`);
		const innerLoopInfo = generateVdbeForStep(
			compiler,
			innerPlannedStep,
			plannedSteps,
			innerStepIndex,
			innerLoopActiveOuterCursors, // Pass combined cursors
			processRowCallback,
			loopContext
		);

		// --- After Inner Loop's VFilter, but inside the inner loop body --- //
		// This is where we need to verify the inner loop plan constraints and check the JOIN ON condition
		log(`  Point after inner loop fetch, inside inner loop body`);

		// Verify constraints associated with the innerLoopPlan
		const innerRelation = (innerPlannedStep.type === 'Scan')
			? innerPlannedStep.relation
			: (innerPlannedStep.type === 'Join' ? innerPlannedStep.outputRelation : null);
		if (!innerRelation) throw new SqliteError(`Internal error: Could not determine inner relation for join step`, StatusCode.INTERNAL);

		// Get the specific cursor for the innerLoopPlan (find the first cursor with planning info)
		const innerCursorIdx = [...innerRelation.contributingCursors][0];
		if (innerCursorIdx !== undefined) {
			log(`    Verifying innerLoopPlan constraints for cursor ${innerCursorIdx} of ${innerAlias}`);
			verifyPlannedConstraints(
				compiler,
				joinStep.innerLoopPlan,
				innerRelation.schema,
				innerCursorIdx,
				joinStep.joinFailAddr, // Jump to join fail address if verification fails
				innerLoopActiveOuterCursors // Pass outer cursors context
			);
		} else {
			warnLog(`Could not determine specific inner cursor index for constraint verification of ${innerAlias}`);
		}

		// Check JOIN ON condition (if exists)
		if (joinStep.condition) {
			const conditionReg = compiler.allocateMemoryCells(1);
			const allCursorsForJoinCond = new Set([...innerLoopActiveOuterCursors, ...innerRelation.contributingCursors]);
			log(`    Compiling JOIN ON condition. Active cursors: {${[...allCursorsForJoinCond].join(',')}}`);
			const correlation = analyzeSubqueryCorrelation(compiler, joinStep.condition, allCursorsForJoinCond);
			compiler.compileExpression(joinStep.condition, conditionReg, correlation);
			// If condition is false, jump to the join fail target
			compiler.emit(Opcode.IfFalse, conditionReg, joinStep.joinFailAddr, 0, null, 0, `Check JOIN ON Condition`);
		}

		// Set LEFT JOIN match flag if verification/ON condition passed
		if (joinStep.joinType === 'left' && joinStep.matchReg !== undefined) {
			// This happens AFTER verification and ON condition check
			compiler.emit(Opcode.Integer, 1, joinStep.matchReg, 0, null, 0, `Set LEFT JOIN Match Flag = 1`);
		}

		// --- Code After Inner Loop (but still inside Outer Loop) --- //
		log(`  After Inner Loop of ${innerAlias} (at addr ${compiler.getCurrentAddress()}, after inner VNext ${innerLoopInfo.vNextAddr}, after inner EOF ${innerLoopInfo.eofAddr})`);

		// Resolve Join Fail Target
		if (joinStep.joinFailAddr !== undefined && !compiler.resolvedAddresses.has(joinStep.joinFailAddr)) {
			log(`   Resolving joinFailAddr ${joinStep.joinFailAddr}`);
			compiler.resolveAddress(joinStep.joinFailAddr);
		}

		// LEFT JOIN Padding
		if (joinStep.joinType === 'left' && joinStep.matchReg !== undefined) {
			const skipPaddingAddr = compiler.allocateAddress(`skipLeftPad_${getStepPrimaryAlias(step)}`);
			// Check the match flag *after* the inner loop is completely finished (after its EOF resolution)
			compiler.emit(Opcode.IfTrue, joinStep.matchReg, skipPaddingAddr, 0, null, 0, `Check Match Flag for LEFT JOIN Padding - Skip if True`);

			// If this is the innermost step overall, we need to emit padding & invoke the callback with the context
			if (isInnermostStep) {
				log(`    JOIN step ${stepIndex} is innermost overall (Padding Path).`);
				const allActiveCursorsForPadding = new Set([...innerLoopActiveOuterCursors, ...innerRelation.contributingCursors]);
				const whereFailTargetForPadding = loopContext.whereFailTargetPlaceholder;

				if (loopContext.whereExpr && whereFailTargetForPadding) {
					log(`    Emitting WHERE check during PADDING at innermost JOIN step ${stepIndex}. Active: {${[...allActiveCursorsForPadding].join(',')}}`);
					compileUnhandledWhereConditions(compiler, loopContext.whereExpr, [...allActiveCursorsForPadding], whereFailTargetForPadding, joinStep);
				}

				// Invoke Row Processing Callback with proper context FOR PADDING
				const paddingProcessingContext: RowProcessingContext = {
					whereFailTarget: whereFailTargetForPadding,
					isLeftJoinPadding: { // This is correctly set
						innerRelation: innerRelation,
						innerContributingCursors: innerRelation.contributingCursors
					},
					finalColumnMap: loopContext.finalColumnMap
				};
				processRowCallback(compiler, null, plannedSteps, allActiveCursorsForPadding, paddingProcessingContext);
			} else {
				// If not innermost, we need to emit the NULLs directly here,
				// then continue with nested execution
				log(`    LEFT JOIN Padding: For intermediate join (not innermost), emitting placeholder NULLs for ${innerAlias}`);
				const innerOutputRelation = (joinStep.innerStep.type === 'Scan')
					? joinStep.innerStep.relation
					: joinStep.innerStep.outputRelation;

				const innerContributingBaseCursors = innerOutputRelation.contributingCursors;

				if (loopContext.coreColumnMap) {
					loopContext.coreColumnMap.forEach((coreColInfo: ColumnResultInfo) => {
						if (innerContributingBaseCursors.has(coreColInfo.sourceCursor)) {
							compiler.emit(Opcode.Null, 0, coreColInfo.targetReg, 0, null, 0, `NULL Pad Intermediate ${innerAlias}.${coreColInfo.expr ? expressionToString(coreColInfo.expr) : 'col'} to reg ${coreColInfo.targetReg}`);
							log(`      NULLing reg ${coreColInfo.targetReg} for intermediate pad of ${innerAlias} (source cursor ${coreColInfo.sourceCursor}, col expr: ${coreColInfo.expr ? expressionToString(coreColInfo.expr) : 'N/A'})`);
						}
					});
				} else {
					warnLog(`Cannot perform intermediate LEFT JOIN padding for ${innerAlias}: coreColumnMap is missing in loopContext.`);
				}
			}
			compiler.resolveAddress(skipPaddingAddr);
		}
		// --- End LEFT JOIN Padding --- //

		// --- Outer Loop Closing is handled by the caller of this function --- //
		// Return the info for the *outer* loop that this JOIN step is part of.
		return {
			...outerLoopInfo, // Return outer loop's info (start, eof, vnext addr/cursor)
			joinFailAddr: joinStep.joinFailAddr, // Pass along specific info if needed
			matchReg: joinStep.matchReg,
			callbackAddr: innerLoopInfo.callbackAddr ?? outerLoopInfo.callbackAddr, // Propagate innermost callback addr if found
			innermostVNextAddr: innerLoopInfo.innermostVNextAddr !== -1 ? innerLoopInfo.innermostVNextAddr : outerLoopInfo.innermostVNextAddr, // Propagate innermost VNext addr
			innermostWhereFailTarget: innerLoopInfo.innermostWhereFailTarget, // Propagate WHERE target placeholder
			verifyFailAddr: joinStep.joinFailAddr, // Propagate verification failure address if needed
		};

	} else {
		const _exhaustiveCheck: never = step;
		errorLog(`Unsupported PlannedStep type in generateVdbeForStep: ${(_exhaustiveCheck as any).type}`);
		return { loopStartAddr: -1, eofAddr: -1, vNextAddr: -1, vNextCursor: -1, innermostVNextAddr: -1 };
	}
}

/**
 * Generates VDBE code for the nested loops defined by the query plan.
 *
 * @param compiler Compiler instance
 * @param stmt Original SELECT statement
 * @param plannedSteps Ordered list of execution steps from the planner
 * @param fromCursors Original list of cursors from FROM (needed for unhandled WHERE)
 * @param processRowCallback Function to call inside the innermost loop
 * @param finalColumnMap Map of final result columns (needed for LEFT JOIN padding)
 * @param coreColumnMap Map of raw FROM columns to registers
 * @returns Addresses for loop control
 */
export function compilePlannedStepsLoop(
	compiler: Compiler,
	stmt: AST.SelectStmt,
	plannedSteps: PlannedStep[],
	fromCursors: ReadonlyArray<number>, // Keep for WHERE check context
	processRowCallback: ProcessRowCallback,
	finalColumnMap: ReadonlyArray<ColumnResultInfo> = [],
	coreColumnMap: ReadonlyArray<ColumnResultInfo> = []
): { innermostLoopStartAddr: number, innermostLoopEndAddrPlaceholder: number } {
	log(`Generating VDBE for SELECT statement at line ${stmt.loc?.start.line ?? 'unknown'}`);

	if (plannedSteps.length === 0) {
		log("No planned steps provided to compilePlannedStepsLoop.");
		return { innermostLoopStartAddr: -1, innermostLoopEndAddrPlaceholder: -1 };
	}

	const innermostLoopEndAddrPlaceholder = compiler.allocateAddress('innermostLoopEnd');
	let whereFailTargetPlaceholder: number | undefined = undefined;
	if (stmt.where) {
		whereFailTargetPlaceholder = compiler.allocateAddress('whereFailTarget');
		log(`Allocated whereFailTargetPlaceholder: ${whereFailTargetPlaceholder}`);
	}

	const loopContext: LoopGenerationContext = {
		innermostLoopEndAddrPlaceholder,
		whereExpr: stmt.where,
		whereFailTargetPlaceholder,
		allFromCursors: new Set(fromCursors), // Pass all cursors for WHERE check context
		finalColumnMap, // Pass the column map in the context
		coreColumnMap   // Pass core column map
	};

	// The first step in the plan *should* be the outer loop driver based on planner logic.
	const firstStep = plannedSteps[0];

	// Generate the VDBE code recursively
	const topLoopInfo = generateVdbeForStep(
		compiler,
		firstStep,
		plannedSteps, // Pass full plan
		0,            // Start at index 0
		new Set<number>(), // Initial call has no outer cursors
		processRowCallback,
		loopContext
	);

	// --- Final Loop Closing (for the outermost loop) --- //
	// The VNext for the outermost loop needs to be emitted *after* all nested
	// loops and potential padding/checks are done.
	if (plannedSteps.length === 1 && plannedSteps[0].type === 'Scan') {
		log("Single SCAN step. Loop is self-contained by VNext in generateVdbeForStep. Outermost EOF resolution handled below.");
		// The eofAddr from topLoopInfo (which is scanStep.eofAddr) is already resolved
		// by generateVdbeForStep for the Scan to point after its own VNext.
		// No additional VNext is needed here.
	} else {
		log(`Emitting final VNext for outermost loop (Cursor ${topLoopInfo.vNextCursor}, Addr ${compiler.getCurrentAddress()}) jumping to LoopStart ${topLoopInfo.loopStartAddr}`);
		compiler.emit(Opcode.VNext, topLoopInfo.vNextCursor, topLoopInfo.loopStartAddr, 0, null, 0, `VNext Outer Loop ${getStepPrimaryAlias(firstStep)} -> ${topLoopInfo.loopStartAddr}`);
		// Resolve the EOF address for the *outermost loop's VFilter/VNext*.
		// This should point after this VNext we just emitted.
		log(`Resolving final EOF address ${topLoopInfo.eofAddr} for outermost loop ${getStepPrimaryAlias(firstStep)} to PC=${compiler.getCurrentAddress()}`);
		compiler.resolveAddress(topLoopInfo.eofAddr);
	}

	// Resolve the final exit point placeholder. All paths should eventually lead here.
	// This is particularly for things like LIMIT/OFFSET or if errors occur before normal loop termination.
	log(`Resolving innermostLoopEndAddrPlaceholder ${innermostLoopEndAddrPlaceholder} to PC=${compiler.getCurrentAddress()}`);
	compiler.resolveAddress(innermostLoopEndAddrPlaceholder);

	// The whereFailTargetPlaceholder is resolved inside generateVdbeForStep
	// after the innermost loop's VNext. No need to resolve it here.
	// However, ensure it was resolved somewhere:
	if (whereFailTargetPlaceholder !== undefined && !compiler.resolvedAddresses.has(whereFailTargetPlaceholder)) {
		warnLog(`whereFailTargetPlaceholder ${whereFailTargetPlaceholder} was not resolved during recursive generation. Resolving to final exit.`);
		compiler.resolveAddress(whereFailTargetPlaceholder);
	}

	log("Finished VDBE generation for planned steps.");

	// Return the start address of the *outermost* loop generated by the top call.
	return { innermostLoopStartAddr: topLoopInfo.loopStartAddr, innermostLoopEndAddrPlaceholder };
}
